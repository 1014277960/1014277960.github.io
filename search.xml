<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android内存泄漏简介]]></title>
    <url>%2F2019%2F10%2F09%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[内存泄漏概念内存泄漏指的是一个本该被回收的对象因为某些原因导致其不能被回收，通俗来说就是该对象理论上不再使用，但是仍无法被回收。 Android中的泄漏对象判断一个对象是否泄漏首先要判断该对象是否不再使用，想要判断这一点则需要对象有明显的生命周期，在Android中有以下对象可以判断是否泄漏: Activity: 通过Activity的mDestroyed属性来判断该Activity是否已经销毁，如果已经销毁且未被回收则认为是泄漏 Fragment: 通过Fragment的mFragmentManager是否为空来判断该Fragment是否处于无用状态，如果mFragmentManager为空且未被回收则认为是泄漏。 View: 通过unwrapper mContext获得Activity，如果存在Activity，则判断该Activity是否泄漏。 Editor: Editor指的是android.widget包下的Editor，是用于TextView处理editable text的辅助类，通过mTextView是否为空来判断Editor是否处于无用状态，如果mTextView为空且未被回收则认为是泄漏。 ContextWrapper: 通过unwrapper ContextWrapper获得Activity，如果存在Activity，则判断该Activity是否泄漏。 Dialog: 通过mDecor是否为空判断该Dialog是否处于无用状态，如果mDecor为空且未被回收则认为是泄漏。 MessageQueue: 通过mQuitting或者mQuiting(应该是历史原因，前期拼写错误为mQuiting，后来改正)来判断MessageQueue是否已经退出，如果已经退出且未被回收则认为是泄漏。 ViewRootImpl: 通过ViewRootImpl的mView是否为空来判断该ViewRootImpl是否处于无用状态，如果mView为空且未被回收则认为是泄漏。 Window: 通过mDestroyed来判断该Window是否处于无用状态，如果mDestroyed为true且未被回收则认为是泄漏。 Toast: 拿到mTN，通过mTN的mView是否为空来判断当前Toast是否已经hide，如果已经hide且未被回收则认为是泄漏。 泄漏的形式泄漏的本质就是无用对象被持有导致无法回收，具体的形式有如下几种： 非静态内部类、匿名内部类持有外部类对象引用: 一般为用于回调的Listener，该Listener被别的地方持有，间接导致外部类对象被泄漏。 Handler: 在Activity中定义Handler对象的时候，Handler持有Activity同时Message持有Handler，而Message被MessageQueue持有，最终导致Activity泄漏。 资源对象未关闭: 数据库连接、Cursor、IO流等使用完后未close。 属性动画: 使用ValueAnimator和ObjectAnimator的时候，未及时关闭动画导致泄漏。Animator内部向AnimationHandler注册listener，AnimationHandler是一个单例，如果不及时cancel，会导致Animator泄漏，间接导致Activity/Fragment/View泄漏（比如Animator的updateListener一般都以匿名内部类实现） 逻辑问题: 注册监听器之后未及时解注册，比如使用EventBus的时候没有在合适的时候进行解注册]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MAT中的Shallow Heap和Retained Heap]]></title>
    <url>%2F2019%2F09%2F24%2FMAT%E4%B8%AD%E7%9A%84ShallowSize%E5%92%8CRetainedSize%2F</url>
    <content type="text"><![CDATA[概述在使用MAT分析内存快照的时候我们一般会关注对象占用的内存大小，在MAT中我们可以观察到两个数据Shallow Heap和Retained Heap，网上有很多文章介绍这两个数据的概念以及计算方式，但是很多文章都是有问题的(因此走了不少弯路)，所以自己研究了一下，接下来分别介绍。 PS:以下均以32位为例 Shallow HeapShallow Heap指的是对象本身占用的内存大小，包含两部分： 对象头：可参考Java的对象头和对象组成详解，总结一下就是普通对象的对象头占8字节，数组对象占12字节(包括4字节的数组长度) 成员变量：如果是基本类型则按照基本类型的大小来算(如int占用4字节，char占用2字节)，如果是对象引用则一律占用4个字节 由以上可得出Shallow Heap计算方法为1Shallow Heap = sizeof(对象头) + sizeof(所有成员变量) 由于对象内存分配是以8字节为单位的，所以最终的Shallow Heap如果不是8的倍数则需要增加至8的倍数 Retained Heap为了能够更好的理解，引入Retained Set 和 Dominator的概念 Dominator：如果GCRoot到对象B的所有路径中均包含对象A，则称A为B的Dominator，意味着如果A被回收，GCRoot将没有到B的链路，B成为可回收对象。 Retained Set：对象A的Retained Set指的是包含所有以A为Dominator的对象的集合 A的Retained Heap就是A和Retained Set中所有对象的Shallow Heap的合，可以理解为A被回收后进行一次GC，包括A可总共回收的内存就是Retained Heap。 Retained Heap计算方法为1Retained Heap = shallowHeapOf(A) + shallowHeapOf(Retained Set内所有对象) 举例接下来举一个例子来应用上述计算方法12345678910111213141516public class A &#123; int i = 0; long l = 0; int[] intArray = new int[2]; char[] charArray = new char[2]; B b = new B();&#125;public class B &#123; int i = 0; long l = 0;&#125;public static void main(String[] args) &#123; A a = new A();&#125; 内存中有一个对象A，A持有对象B，我们首先来计算A、B的Shallow Heap 计算Shallow HeapA持有两个基本类型的变量i、l和三个对象引用(数组也是对象！)，所以 Shallow Heap = 8(对象头) + 4(int) + 8(long) + 4(对象引用) + 4(对象引用) + 4(对象引用) = 32 B就只有两个基本类型的变量，所以 Shallow Heap = 8(对象头) + 4(int) + 8(long) = 20 但是20不是8的倍数，所以真正的Shallow Heap为24 计算Retained Heap由于B没有持有任何对象引用，所以Retained Heap就是Shallow Heap，为24A持有三个对象引用，所以 Retained Heap(A) = Shallow Heap(A) + 三个对象的Retained Heap intArray不持有对象，只持有基本类型int，所以 Retained Heap(intArray) = Shallow Heap(intArray) = 12(对象头) + 4(int) * 2 = 20 -&gt; 24 charArray同样不持有对象，只持有基本类型char，所以 Retained Heap(charArray) = Shallow Heap(charArray) = 12(对象头) + 2(char) * 2 = 16 综上 Retained Heap(A) = 32(Shallow Heap) + 24(int[]) + 16(char[]) + 24(b) = 96 参考文章Shallow and retained heapJava的对象头和对象组成详解Immediate Dominators]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Hprof的方方面面]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%85%B3%E4%BA%8EHprof%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Hprof概述hprof最初是由J2SE支持的一种二进制堆转储格式，hprof文件保存了当前java堆上所有的内存使用信息。 格式详细的Hprof标准格式可以参考HPROF Agent(强烈建议首先阅读该文档，本文仅挑部分重点详解)，本节将根据该文档简单介绍Hprof格式。Hprof可分为Head和Body两部分，Head主要是包含固定信息、字符串信息、简单的类信息、栈信息，Body部分包含GcRoot信息、对象信息、详细的类信息。除去头部固定信息，其余的信息格式都是由Tag、Time、Length、Body组成，我们称之为一个Record。 1 4 4 Length tag time length body 不同类型的Record的body部分格式不同，接下来分析一些比较重要的Record。 HeadFixedHeadHprof首先包含了文件的版本描述及版本号，一般固定为”JAVA PROFILE 1.0.2”，以/0结尾，随后是长度为4字节的ID标识的size，最后是长度为8字节的时间戳。hprof文件中几乎所有类型的record都有用到id，这里的ID size指的就是这个id的长度，用来告诉我们需要读取多少字节的内容来获取id。 19 4 8 “JAVA PROFILE 1.0.2/0” ID size 时间戳 StringTableFixedHead后面就是一系列的String Record，Tag为0x01，用于存储String与id的映射关系。这里的String存储了后面将用到字符串，包括类名，常量等。String Record的body包含一个id和长度为(Length - idSize)的字符串(因为body部分的长度为Length，所以字符串内容部分的长度时候Length - idSize)。 LOAD CLASSLOAD CLASS Record记录了简单的类信息，Tag为0x02。body部分包含了4个字节长的序列号、类id、4个字节长的栈序列号、类名id，可以通过类名id从上述的一系列String Record中找到当前类的类名。 BodyHprof文件的Body部分主要是两个Record，HEAP DUMP和HEAP DUMP SEGMENT。这两个Record主要是包含GcRoot信息、对象信息、详细的类信息，在解析Hprof的时候这两个Record对我们来说作用是一样的(不知道为啥分成两个Record？)，接下来就以HEAP DUMP为例。HEAP DUMP是一个非常大的Record，内部包含了一系列的SubRecord，每个SubRecord均以一个字节的SubTag开头，接下来一一解析这些SubRecord。 ROOT XXX首先是一系列的GCRoot，SubTag范围是 0x01到0x08 和 0xFF 这9个，每个GCRoot的Record均有一个Object Id，用来表示该GCRoot对应的Object，其余的部分参考文档。 CLASS DUMPCLASS DUMP包含详细的类信息，SubTag为0x20，接下来按照顺序来解析body部分的内容 class object ID：与上面的LOAD CLASS中的类Id一致，所以可以通过之前的LOAD CLASS来得到当前类的类名 stack trace serial number：四个字节的栈序列号 super class object ID：父类的类Id class loader object ID：类加载器的Object Id signers object ID：暂不清楚作用 protection domain object ID：暂不清楚作用 reserved：两个reserved Id，不清楚作用 instance size (in bytes)：四个字节的类实例占用的大小 constant pool：两个字节的常量池数量n，接下来包含n个常量池Record，每一个常量池Record包含两个字节的index、一个字节的类型信息、x个字节的常量值。其中x根据该常量的类型决定，Object类型的值为一个Object Id，具体参考文档。 静态变量信息：和constant pool十分类似，唯一区别是2个字节的index替换为变量Name Id，用来表示该静态变量的变量名 成员变量信息：首先也是2个字节的数量n，接下来是n个成员变量Record，每一个Record包含一个Name Id和1个字节的变量类型 综上，CLASS DUMP包含了类的类加载器、父类、实例大小、常量池、静态变量、成员变量的信息。 INSTANCE DUMPINSTANCE DUMP包含类对象的信息，SubTag为0x21。包含了一个Object Id、4个字节的栈序列号、类Id、4个字节的长度n、成员变量信息。其中长度n表示后面的成员变量信息占用了多少字节。成员变量信息是该对象所有成员变量的值组合在一起(包括父类的成员变量)，读取方式如下： 从上述CLASS DUMP中获得当前类的成员变量信息，按照该信息顺序依次读取变量值(比如Char读取两个字节的长度，Object读取idSize的长度) 获得父类的成员变量信息，重复上述操作，直至没有父类为止 OBJECT ARRAY DUMP 和 PRIMITIVE ARRAY DUMP这两个SubRecord存储数组对象的信息，比较简单，可以参考文档自行分析。 Android中的hprof在Android设备上，我们可以通过两种方式生成当前进程的hprof文件 通过调用Debug.dumpHprofData(String filePath)方法来生成hprof 通过执行shell命令adb shell am dumpheap pid /data/local/tmp/x.hprof来生成指定进程的hprof文件到目标目录 然而Android平台上的hprof文件和标准Java的hprof定义有一些区别，主要是版本号不一样，而且增加了一些特殊Tag，在art/runtime/hprof/hprof.cc中有如下定义可以看出Android增加了额外的9个HeapTag，其中比较重要的是HPROF_HEAP_DUMP_INFO。这个Tag的作用是切换当前的堆，包括Heap-App、Heap-Image、Heap-Zygote。该Tag后面紧跟着一个四个字节的堆Id和一个堆名称Id，用于标示后续的所有Record内存均存放在该堆中。如果想使用MAT等标准hprof工具来分析Android生成的hprof，我们需要使用AndroidSDK提供的hprof-conv工具将hprof转换为标准hprof，该工具在sdk/platform-tools下，使用方式如下12// 其中-z表示忽略除app堆以外的堆(Image/Zygote)hprof-conv [-z] infile outfile hprof-conv具体做了什么呢？接下来通过hprof-conv的源码来分析 修改版本信息首先是将版本信息从”JAVA PROFILE 1.0.3”降为”JAVA PROFILE 1.0.2”，如果当前版本不是”JAVA PROFILE 1.0.3”则报错。 修改HeapTag信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129while (len &gt; 0) &#123; unsigned char subType = buf[0]; int justCopy = TRUE; int subLen; DBUG("--- 0x%02x ", subType); switch (subType) &#123; /* 1.0.2 types */ case HPROF_ROOT_UNKNOWN: subLen = kIdentSize; break; case HPROF_ROOT_JNI_GLOBAL: subLen = kIdentSize * 2; break; case HPROF_ROOT_JNI_LOCAL: subLen = kIdentSize + 8; break; case HPROF_ROOT_JAVA_FRAME: subLen = kIdentSize + 8; break; case HPROF_ROOT_NATIVE_STACK: subLen = kIdentSize + 4; break; case HPROF_ROOT_STICKY_CLASS: subLen = kIdentSize; break; case HPROF_ROOT_THREAD_BLOCK: subLen = kIdentSize + 4; break; case HPROF_ROOT_MONITOR_USED: subLen = kIdentSize; break; case HPROF_ROOT_THREAD_OBJECT: subLen = kIdentSize + 8; break; case HPROF_CLASS_DUMP: subLen = computeClassDumpLen(buf+1, len-1); break; case HPROF_INSTANCE_DUMP: subLen = computeInstanceDumpLen(buf+1, len-1); // 如果当前堆被忽略(带了-z参数)则丢弃该tag if (heapIgnore) &#123; justCopy = FALSE; &#125; break; case HPROF_OBJECT_ARRAY_DUMP: subLen = computeObjectArrayDumpLen(buf+1, len-1); // 如果当前堆被忽略(带了-z参数)则丢弃该tag if (heapIgnore) &#123; justCopy = FALSE; &#125; break; case HPROF_PRIMITIVE_ARRAY_DUMP: subLen = computePrimitiveArrayDumpLen(buf+1, len-1); // 如果当前堆被忽略(带了-z参数)则丢弃该tag if (heapIgnore) &#123; justCopy = FALSE; &#125; break; /* these were added for Android in 1.0.3 */ // 以下为Android新加HeapTag case HPROF_HEAP_DUMP_INFO: // 如果带了-z参数则丢弃HPROF_HEAP_ZYGOTE和HPROF_HEAP_IMAGE堆的数据 heapType = get4BE(buf+1); if ((flags &amp; kFlagAppOnly) != 0 &amp;&amp; (heapType == HPROF_HEAP_ZYGOTE || heapType == HPROF_HEAP_IMAGE)) &#123; heapIgnore = TRUE; &#125; else &#123; heapIgnore = FALSE; &#125; justCopy = FALSE; subLen = kIdentSize + 4; // no 1.0.2 equivalent for this break; case HPROF_ROOT_INTERNED_STRING: // 将tag名改为HPROF_ROOT_UNKNOWN buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_ROOT_FINALIZING: buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_ROOT_DEBUGGER: buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_ROOT_REFERENCE_CLEANUP: buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_ROOT_VM_INTERNAL: buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_ROOT_JNI_MONITOR: /* keep the ident, drop the next 8 bytes */ buf[0] = HPROF_ROOT_UNKNOWN; justCopy = FALSE; ebAddData(pOutBuf, buf, 1 + kIdentSize); subLen = kIdentSize + 8; break; case HPROF_UNREACHABLE: buf[0] = HPROF_ROOT_UNKNOWN; subLen = kIdentSize; break; case HPROF_PRIMITIVE_ARRAY_NODATA_DUMP: // 将空array tag改为array tag且将长度设置为0 buf[0] = HPROF_PRIMITIVE_ARRAY_DUMP; buf[5] = buf[6] = buf[7] = buf[8] = 0; /* set array len to 0 */ subLen = kIdentSize + 9; break; /* shouldn't get here */ default: fprintf(stderr, "ERROR: unexpected subtype 0x%02x at offset %zu\n", subType, (size_t) (buf - origBuf)); goto bail; &#125; if (justCopy) &#123; /* copy source data */ DBUG("(%d)\n", 1 + subLen); ebAddData(pOutBuf, buf, 1 + subLen); &#125; else &#123; /* other data has been written, or the sub-record omitted */ DBUG("(adv %d)\n", 1 + subLen); &#125; /* advance to next entry */ buf += 1 + subLen; len -= 1 + subLen; &#125; 主要做了4件事 针对标准hprof的HeapTag除了HPROF_INSTANCE_DUMP、HPROF_OBJECT_ARRAY_DUMP、HPROF_PRIMITIVE_ARRAY_DUMP照常写入，不做更改 Android新增的Tag除了HPROF_HEAP_DUMP_INFO、HPROF_PRIMITIVE_ARRAY_NODATA_DUMP，都将Tag改为HPROF_ROOT_UNKNOWN写入，同时将HPROF_PRIMITIVE_ARRAY_NODATA_DUMP改为长度为0的HPROF_PRIMITIVE_ARRAY_DUMP 丢弃HPROF_HEAP_DUMP_INFO Tag不写入，同时根据命令是否携带-z参数来判断当前堆是否需要写入，更新heapIgnore标志位 针对HPROF_INSTANCE_DUMP、HPROF_OBJECT_ARRAY_DUMP、HPROF_PRIMITIVE_ARRAY_DUMP，如果当前堆不需要写入，即heapIgnore = TRUE，则丢弃当前Record信息 参考资料 hprof.cc HprofConv.c]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2019%2F08%2F08%2F%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[贝塞尔原理贝塞尔曲线(Bézier curve)，又称贝兹曲线，是应用于二维图形应用程序的数学曲线，贝塞尔曲线的运用十分广泛，可以说贝塞尔曲线奠定了计算机绘图的基础(因为它可以将任何复杂的图形用精确的数学语言进行描述)，接下来以二阶贝塞尔曲线为例介绍贝塞尔曲线的定义、性质。二阶曲线由两个数据点(P0 和 P2)，一个控制点(P1)来描述曲线状态，如图所示红色曲线就是二阶贝塞尔曲线推导过程如下 在P0P1、P1P2上分别取点A、B满足 P0A/P0P1 = P1B/P1P2 = t 在AB上取点C满足 AC/AB = tC为贝塞尔曲线上一个点，当t从0-1变化时，所有满足条件的点C构成完整的贝塞尔曲线，公式为二阶贝塞尔曲线有两个特性: 以P0P2为底边，二阶贝塞尔曲线最高点的坐标为P1P3的中点，其中P3为P0P2的中点。 贝塞尔曲线与P0P1、P1P2分别相切于P0、P2点 三阶贝塞尔曲线如下如所示，构造过程和二阶类似 应用一:实现粘性效果使用贝塞尔曲线可以实现很多复杂的动画效果，这里介绍一种较为简单的小球粘性下拉动画，效果如下首先我们定义小球可以下拉的最大高度为MAX_HEIGHT，当小球随手势向下拉动的时候通过当前的高度/MAX_HEIGHT计算出当前的进度progress，后面就通过progress来确定绘制所需要的所有点如图所示在圆上取点e1，e1与圆心连城的直线与垂线夹角为θ。过e1做圆的切线交基准线L于c1点，取基准线上s1点和e1为数据点，c1为控制点做二阶贝塞尔曲线(右侧类似)即可实现粘性效果。其中随着progress从0到1变化过程中 θ从0到105度变化 s1从最左侧到距离O点120距离移动以下是添加辅助点后的效果 应用二:平滑拟合曲线在一些绘图应用上会提供用户手动绘制的功能，绘制的曲线其实是一个一个点连接而成的，这样就会导致曲线可能并不光滑，出现很多折角，这种情况就可以用贝塞尔曲线进行拟合，拟合方法如下：假设绘制路径上有三个连续的点a、b、c，则分别取ab、bc中点A、B，以AB为数据点，b为控制点绘制二阶贝塞尔曲线。使用如上方法就可以实现平滑曲线绘制，部分代码如下12345678910111213141516171819202122232425262728293031/** * author：wulinpeng * date：2019/5/27 22:26 * desc: 平滑绘制Path，将lineTo通过二阶贝塞尔转换 */class SmoothCurvePath: Path() &#123; private val points = mutableListOf&lt;PointF&gt;() override fun moveTo(x: Float, y: Float) &#123; super.moveTo(x, y) points.add(PointF(x, y)) &#125; override fun lineTo(x: Float, y: Float) &#123; points.add(PointF(x, y)) makeBezier() &#125; private fun makeBezier() &#123; val size = points.size val prePoint = points[size - 2] val curPoint = points[size - 1] quadTo(prePoint.x, prePoint.y, (prePoint.x + curPoint.x) / 2, (prePoint.y + curPoint.y) / 2) &#125; override fun reset() &#123; super.reset() points.clear() &#125;&#125; 效果如下 应用三:小说仿真翻页效果目前市面上的小说阅读app基本都提供仿真翻页阅读的功能，本节将详细介绍实现的细节，demo效果如下 原理解析本节着重讲解实现翻页效果的理论知识，下面这张图是整个翻页效果的精髓所在，接下来以从右下角开始翻页为例进行讲解。 如图2所示，黄色区域为当前页面的背面，蓝色区域为下一页的内容，绿色为当前页面，我们第一步要做的就是确定三块区域对应的Path，这样后面才可以在Canvas上绘制对应的内容。如图3所示，三角形aeh与三角形feh关于eh对称，aeh也就是我们翻页的部分，但是如果就按照这样来绘制显得不够逼真，没有真实翻页的效果，所以我们需要给翻页部分做一个平滑过渡的效果。经过ag中点做直线cj牌型与eh，交与三角形aeh于b、k点，且c、j为边界上的点。以cb为二阶贝塞尔曲线数据点，e为控制点做贝塞尔曲线，由贝塞尔性质可知该曲线与ce、ab相切，可以达到平滑过渡的效果。同理以ja为二阶贝塞尔曲线数据点，h为控制点做贝塞尔曲线平滑多度ih、ak。分别取两条贝塞尔曲线的定点d、i连接，则d、b、a、k、i5个点连接的区域为图2黄色区域，也就是当前页背页的区域。有了黄色区域的范围，就可以很简单的求得蓝色区域和绿色区域的范围了。 代码实现实现整体的效果非常复杂，本节重点讲解几个比较关键的点，首先将图3中的点命名 a -&gt; mTouch f -&gt; mCorner b/c/d/e -&gt; mBzEnd1/mBzStart1/mBzVertex1/mBzControl1 h/i/j/k -&gt; mBzControl2/mBzVertex2/mBzStart2/mBzEnd21.mTouch点的确定由于在实际触摸中会出现控制点超出屏幕的情况，所以这时候不能将触摸点当作mTouch的坐标，而是应该进行转换。转换原理是将超出屏幕的控制点缩小到屏幕的临界点(刚好不超出屏幕)，计算该缩放的比例，将触摸点按该比例向mCorner点缩小。2.获得黄色区域Path由于d-&gt;b / i-&gt;k的曲线为贝塞尔曲线的一部分，我们无法直接通过Path来构造，只能通别的方式来获得到。第一步我们先获取黄色和蓝色区域的并集Path1，这一块没有什么难度，其中quadTo是连接二阶贝塞尔曲线123456789val path1 = Path().apply &#123; moveTo(mBzStart1.x, mBzStart1.y) quadTo(mBzControl1.x, mBzControl1.y, mBzEnd1.x, mBzEnd1.y) lineTo(mTouch.x, mTouch.y) lineTo(mBzEnd2.x, mBzEnd2.y) quadTo(mBzControl2.x, mBzControl2.y, mBzStart2.x, mBzStart2.y) lineTo(mCornerX, mCornerY) close()&#125; 第二步将dbaki通过线段连接得到Path212345678val path2 = Path().apply &#123; moveTo(mBzVertex1.x, mBzVertex1.y) lineTo(mBzVertex2.x, mBzVertex2.y) lineTo(mBzEnd2.x, mBzEnd2.y) lineTo(mTouch.x, mTouch.y) lineTo(mBzEnd1.x, mBzEnd1.y) close()&#125; 由于Path2使用的是线段相连，所以比我们想要获得的黄色区域要多出一部分，而恰好Path2只有这部分不在Path1中，所以我们可以通过取Path1和Path2的并集求得黄色区域的范围12345678val matrix = getSymmetricalMatrix(mCalcData.mBzControl1, mCalcData.mBzControl2)canvas.save()canvas.clipPath(mPath1)canvas.clipPath(mPath2, Region.Op.INTERSECT)// 当前页面对称变换后的矩形会和背页区域有一定的空隙，故背页不绘制正常bg，只绘制文字，在此之前填充背景色canvas.drawColor(mBackPageColor)canvas.drawBitmap(curBitmapWithNormalBg, matrix, null)canvas.restore() 这里在绘制背页的时候需要注意两个点 绘制文字的时候需要做关于eh的对称变化，这样才有背页的效果，我们需要做的是构造一个矩阵来实现，若点A1(X1,Y1)关于直线y=kx+b成轴对称，则对应点A2（X2，Y2）的坐标为 那么就可以求出对应的矩阵1234567891011121314151617181920/** * 关于两个control连线的对称矩阵 */private fun getSymmetricalMatrix(point1: PointF, point2: PointF): Matrix &#123; val k = (point1.y - point2.y) / (point1.x - point2.x) val values = FloatArray(9) values[0] = -1 * (k * k - 1) / (k * k + 1) values[1] = 2 * k / (k * k + 1) values[3] = values[1] values[4] = -values[0] values[8] = 1f val b = point1.y - point1.x * k values[2] = -2 * k * b / (k * k + 1) values[5] = 2 * b / (k * k + 1) val matrix = Matrix() matrix.setValues(values) return matrix&#125; 由于背页使用了贝塞尔曲线进行平滑扩展，所以绘制的区域是比实际区域要大，在绘制背页的时候不能带背景图片，只能用纯色填充，不然会出现空白区域]]></content>
      <categories>
        <category>贝塞尔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android共享元素动画原理解析]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Andriod 5.0及之后开始支持Activity之间的共享元素动画，共享元素即启动Activity的时候，Activity A中的控件能够通过动画的方式流畅的过渡到Activity B中对应的控件。之前在项目中用到了共享元素动画，遇到了一些坑，碍于不了解底层原理&amp;时间紧迫，实现的效果并不完美。最近得空带着一些疑惑阅读了一波源码，本文将带着这些问题来一步步解析源码，下图为实现效果。PS:本文源码基于android-28 使用共享元素动画使用共享元素动画很简单，只需要三步 通过给两个Activity设定Window.FEATURE_CONTENT_TRANSITIONS来启用transition api 给两个Activity对应的控件加上transitionName属性，且对应控件的transitionName应该保持一致 使用public void startActivity(Intent intent, @Nullable Bundle options)方法启动Activity1234startActivity(Intent(this, TargetActivity::class.java), createTransitionBundle())private fun createTransitionBundle(): Bundle? &#123; return ActivityOptionsCompat.makeSceneTransitionAnimation(this, Pair(avatar, "avatar"), Pair(bg, "bg"), Pair(user_name, "user_name")).toBundle()&#125; ActivityOptionsCompat.makeSceneTransitionAnimation方法接受类型为Pair的可变长数组，对应参与共享元素动画的View和transitionName，该方法可以支持多个共享元素。 通过以上方式就已经可以简单的实现共享元素动画，但是如果被启动的Activity中对应的View因为某些原因(等待网络请求等)不能立即展示，而是需要等待一段时间才能显示，那么在View没有显示的时候做共享元素动画显然是不合理的，所以Android提供了两个方法让我们可以延迟动画的开始时机1234// 延迟enter动画supportPostponeEnterTransition()// 开始执行enter动画supportStartPostponedEnterTransition() 我们可以在被启动的Activity的onCreate方法中调用supportPostponeEnterTransition()来延迟动画的执行，并在我们认为时机到了的时候(View被正常绘制后)调用supportStartPostponedEnterTransition()来开始执行共享元素动画。 共享元素动画大致流程本节大致介绍一下从startActivity到动画执行完毕的过程中发生了什么事情，以便对共享元素动画有一个大致的认识，这样更加有利于理解后续的源码解析。首先引入五个类，这五个类承担共享元素动画的大部分逻辑。 ResultReceiver：ResultReceiver是一个用来接收其他进程回调结果的通用接口。要使用它，需要创建一个子类并且实现onReceiveResult(int, android.os.Bundle)方法，在其他线程（进程）中可以通过send(int, android.os.Bundle)方法发送数据，底层实现是对Binder的简单封装 ActivityTransitionCoordinator：继承自ResultReceiver，是ExitTransitionCoordinator 和 EnterTransitionCoordinator的基类,负责管理Activity的动画和Activity之间的通信 EnterTransitionCoordinator：继承自ActivityTransitionCoordinator，负责启动Activity时的enter动画 ExitTransitionCoordinator：继承自ActivityTransitionCoordinator，负责启动Activity时的exit动画 ActivityTransitionState：与Activity交互，作为Activity与ActivityTransitionCoordinator间的沟通桥梁 一次典型的startActivity动画流程如下所示: ExitTransitionCoordinator在ActivityOptions#makeSceneTransitionAnimation方法中被创建，并将它传入options中返回 Activity#startActivity最终调用到cancelInputsAndStartExitTransition()触发ExitTransitionCoordinator#startExit()，隐藏其余的View同时将SharedViews移动到顶层 Activity B启动，通过ActivityTransitionState#enterReady来创建EnterTransitionCoordiantor，同时调用它的startEnter()做一些准备操作 MSG_SET_REMOTE_RECEIVER被发送给ExitTransitionCoordinator来设置相互的引用 将Window设置为透明 Window的background设置为alpha=0 将不参与SharedTransition的View和SharedViews设置为alpha=0 将SharedViews移动到顶层 ExitTransitionCoordinator的exit动画结束后发送MSG_TAKE_SHARED_ELEMENTS给EnterTransitionCoordinator，EnterTransitionCoordinator开始动画 SharedViews设置为alpha=1 SharedView的位置和大小被设置为启动Activity对应Views的原始状态 开始共享元素动画 发送MSG_HIDE_SHARED_ELEMENTS给ExitTransitionCoordinator通知启动Activity隐藏对应的SharedViews ExitTransitionCoordinator同时发送MSG_EXIT_TRANSITION_COMPLETE给EnterTransitionCoordinator，通知它可以开始EnterTransition动画(不是SharedEnterTransitino) 动画结束后Activity A回调onStop()触发被隐藏的Views恢复显示 Activity A的Shared Views是怎么传递给Activity B的其实传递View这种说法并不准确，准确来说是将View的相关参数传递给Activity B，使得Activity B可以根据这些参数来构造出和Activity A上一样的View。首先ExitTransitionCoordinator会在构造方法中调用父类的viewsReady(mapSharedElements(accepted, mapped))方法来收集当前Activity参与共享元素动画的所有View，并赋值给mSharedElements和mSharedElementNames，分别表示共享元素View和对应Name的集合，同时获取当前Activity中所有可见性为Visible的View并赋值给mTransitionViews123456789101112131415161718192021222324252627// ExitTransitionCoordinator.javaprotected ArrayMap&lt;String, View&gt; mapSharedElements(ArrayList&lt;String&gt; accepted, ArrayList&lt;View&gt; localViews) &#123; ... if (decorView != null) &#123; // 遍历child获得所有transitionName不为空且Visible的View decorView.findNamedViews(sharedElements); &#125; ... return sharedElements;&#125;protected void viewsReady(ArrayMap&lt;String, View&gt; sharedElements) &#123; sharedElements.retainAll(mAllSharedElementNames); if (mListener != null) &#123; mListener.onMapSharedElements(mAllSharedElementNames, sharedElements); &#125; // 将mSharedElements和mSharedElementNames赋值 setSharedElements(sharedElements); ... if (decorView != null) &#123; // 获取所有Visibile的View到mTransitioningViews中 decorView.captureTransitioningViews(mTransitioningViews); &#125; mTransitioningViews.removeAll(mSharedElements); ...&#125; 随后ExitTransitionCoordinator会在ExitTransition执行完毕后会触发captureSharedElementState()来构造共享元素的相关参数，返回一个Bundle赋值给mSharedElementBundle，然后调用notifyComplete()将mSharedElementBundle发送给Activity B的EnterTransitionCoordinator通知可以开始动画123456protected void notifyComplete() &#123; ... // resultReceiver就是Activity B的EnterTransitionCoordinator resultReceiver.send(MSG_TAKE_SHARED_ELEMENTS, sharedElementBundle); ...&#125; 我们着重查看captureSharedElementState()方法的实现12345678910111213141516171819202122232425262728293031// ExitTransitionCoordinator.javaprotected Bundle captureSharedElementState() &#123; Bundle bundle = new Bundle(); RectF tempBounds = new RectF(); Matrix tempMatrix = new Matrix(); for (int i = 0; i &lt; mSharedElements.size(); i++) &#123; View sharedElement = mSharedElements.get(i); String name = mSharedElementNames.get(i); captureSharedElementState(sharedElement, name, bundle, tempMatrix, tempBounds); &#125; return bundle;&#125;protected void captureSharedElementState(View view, String name, Bundle transitionArgs, Matrix tempMatrix, RectF tempBounds) &#123; Bundle sharedElementBundle = new Bundle(); tempMatrix.reset(); view.transformMatrixToGlobal(tempMatrix); tempBounds.set(0, 0, view.getWidth(), view.getHeight()); tempMatrix.mapRect(tempBounds); sharedElementBundle.putFloat(KEY_SCREEN_LEFT, tempBounds.left); sharedElementBundle.putFloat(KEY_SCREEN_RIGHT, tempBounds.right); sharedElementBundle.putFloat(KEY_SCREEN_TOP, tempBounds.top); sharedElementBundle.putFloat(KEY_SCREEN_BOTTOM, tempBounds.bottom); sharedElementBundle.putFloat(KEY_TRANSLATION_Z, view.getTranslationZ()); sharedElementBundle.putFloat(KEY_ELEVATION, view.getElevation()); // 忽略对ImageView的特殊处理 ... transitionArgs.putBundle(name, sharedElementBundle);&#125; 主要是遍历mSharedElements和mSharedElementNames通过captureSharedElementState(View, String, Bundle, Matrix, RectF)来更新每一个共享元素的State到Bundle中。最关键的就是将left、top、right、bottom参数放入bundle中传递给Activity B，然而这里的参数并不是通过View#getLeft()等方法拿到的，而是通过一些运算得到的1234tempMatrix.reset();view.transformMatrixToGlobal(tempMatrix);tempBounds.set(0, 0, view.getWidth(), view.getHeight());tempMatrix.mapRect(tempBounds); 12345678910111213141516171819202122232425// View.javapublic void transformMatrixToGlobal(Matrix m) &#123; final ViewParent parent = mParent; if (parent instanceof View) &#123; final View vp = (View) parent; vp.transformMatrixToGlobal(m); m.preTranslate(-vp.mScrollX, -vp.mScrollY); &#125; else if (parent instanceof ViewRootImpl) &#123; final ViewRootImpl vr = (ViewRootImpl) parent; vr.transformMatrixToGlobal(m); m.preTranslate(0, -vr.mCurScrollY); &#125; m.preTranslate(mLeft, mTop); // 这里将m前乘view.getMatrix是为了避免本身自带的Matrix造成的误差 if (!hasIdentityMatrix()) &#123; m.preConcat(getMatrix()); &#125;&#125;// ViewRootImpl.javavoid transformMatrixToGlobal(Matrix m) &#123; m.preTranslate(mAttachInfo.mWindowLeft, mAttachInfo.mWindowTop);&#125; 我们查看View#transformMatrixToGlobal()方法可以看出内部是向上遍历调用Parent的transformMatrixToGlobal方法直到ViewRootImpl，然后将由Parent处理后的Matrix做preTranslate(mLeft, mTop)操作，而ViewRootImpl#transformMatrixToGlobal方法也是对Metrix做preTranslate，距离是当前Window在屏幕上的left/top，所以一般来说该方法返回的是所有Parent的preTranslate(mLeft, mTop)叠加结果，返回的Matrix为 $$ \left\{ \begin{matrix} 1 & 0 & leftOnScreen \\ 0 & 1 & topOnScreen \\ 0 & 0 & 1 \\ \end{matrix} \right\} $$ 其中leftOnScreen和topOnScreen就是该View距离屏幕的左边/上边的距离。但是真实情况返回Matrix的不一定是这样，因为View自身的Matrix可能并不是一个单位矩阵(设置过scale/rotation等)，所以在拿到处理过的matrix后还需要做一次变换123if (!hasIdentityMatrix()) &#123; m.preConcat(getMatrix());&#125; 将这样处理后的Matrix作用于rect = [0, 0, view.getWidth(), view.getHeight()]的矩形就能够得到视觉上该View在屏幕上的坐标。 我们举个例子来说明这个方法，假设图中A代表屏幕，B为一个ViewGroup，左上角在A中的坐标为(100, 100)，C长宽均为100，是B的child view，左上角在B中的坐标是(50, 50)，同时C设置了transaltion，x、y均偏移25也就是图中灰色的区域(绿色区域为C的真实位置)。C的transformMatrixToGlobal方法中首先获取到Parent也就是B的Matrix，得到的是x、y偏移100的矩阵 $$ B= \left\{ \begin{matrix} 1 & 0 & 100 \\ 0 & 1 & 100 \\ 0 & 0 & 1 \\ \end{matrix} \right\} $$ 随后将矩阵B偏移C在Parent中的left/top $$ C= \left\{ \begin{matrix} 1 & 0 & 100 \\ 0 & 1 & 100 \\ 0 & 0 & 1 \\ \end{matrix} \right\} * \left\{ \begin{matrix} 1 & 0 & 50 \\ 0 & 1 & 50 \\ 0 & 0 & 1 \\ \end{matrix} \right\} = \left\{ \begin{matrix} 1 & 0 & 150 \\ 0 & 1 & 150 \\ 0 & 0 & 1 \\ \end{matrix} \right\} $$ 因为C本身设置了translation，所以自身有一个非单位矩阵，将C乘以该矩阵得到最终的矩阵C2 $$ C2= \left\{ \begin{matrix} 1 & 0 & 150 \\ 0 & 1 & 150 \\ 0 & 0 & 1 \\ \end{matrix} \right\} * \left\{ \begin{matrix} 1 & 0 & 25 \\ 0 & 1 & 25 \\ 0 & 0 & 1 \\ \end{matrix} \right\} = \left\{ \begin{matrix} 1 & 0 & 175 \\ 0 & 1 & 175 \\ 0 & 0 & 1 \\ \end{matrix} \right\} $$ 可以看出该矩阵的作用就是将坐标在x、y方向上移动175的距离，将该矩阵作用于长宽与C一样的矩形(0, 0, 100, 100)得到的就是我们看到的灰色区域，所以该方法最后得到的就是我们所能看到的View在屏幕上的坐标(而不是真正的坐标)。 看到这里大家一定有一个疑问，为什么不直接用getLocationOnScreen方法？其实这两种方法是有差别的。一方面getLocationOnScreen只能获得该View左上角在屏幕中的坐标而无法获得View右下角在屏幕中的坐标，另一方面如果View或者View的Parent设置了rotation，那么就会导致getLocationOnScreen方法获取不准确，因为getLocationOnScreen方法内部实现是针对点来做矩阵变换的，这样就会导致带有rotation的矩阵将左上角的点(0, 0)进行旋转，进而导致结果不准确。而transformMatrixToGlobal方法直接返回作用的Matrix，我们将该Matrix作用在矩形上，就可以获取准确的坐标。总结：Activity A传递给Activity B的是视觉上Shared Views在屏幕中的坐标。 Activity B的是怎么处理Activity A传递的Bundle并实现动画上文提到ExitTransitionCoordiantor的exit动画结束后会发送MSG_TAKE_SHARED_ELEMENTS给被启动Activity的EnterTransitionCoordinator通知它可以开始动画，在EnterTransitionCoordinator中将执行startSharedElementTransition方法1234567891011121314151617181920212223242526272829303132333435363738394041// EnterTransitionCoordinator.java@Overrideprotected void onReceiveResult(int resultCode, Bundle resultData) &#123; switch (resultCode) &#123; case MSG_TAKE_SHARED_ELEMENTS: if (!mIsCanceled) &#123; mSharedElementsBundle = resultData; onTakeSharedElements(); &#125; break; ... &#125;&#125;private void onTakeSharedElements() &#123; if (!mIsReadyForTransition || mSharedElementsBundle == null) &#123; return; &#125; final Bundle sharedElementState = mSharedElementsBundle; mSharedElementsBundle = null; OnSharedElementsReadyListener listener = new OnSharedElementsReadyListener() &#123; @Override public void onSharedElementsReady() &#123; final View decorView = getDecor(); if (decorView != null) &#123; OneShotPreDrawListener.add(decorView, false, () -&gt; &#123; startTransition(() -&gt; &#123; // 将Activity A传递过来的带有View参数的bundle传递，并开始动画 startSharedElementTransition(sharedElementState); &#125;); &#125;); decorView.invalidate(); &#125; &#125; &#125;; if (mListener == null) &#123; listener.onSharedElementsReady(); &#125; else &#123; mListener.onSharedElementsArrived(mSharedElementNames, mSharedElements, listener); &#125;&#125; 我们着重关注startSharedElementTransition方法1234567891011121314151617181920212223242526// EnterTransitionCoordinator.javaprivate void startSharedElementTransition(Bundle sharedElementState) &#123; ... // Now start shared element transition ArrayList&lt;View&gt; sharedElementSnapshots = createSnapshots(sharedElementState, mSharedElementNames); showViews(mSharedElements, true); scheduleSetSharedElementEnd(sharedElementSnapshots); // 将Activity B上的Shared Views设置为Activity A上的初始状态，并返回在Activity B中的原始状态 ArrayList&lt;SharedElementOriginalState&gt; originalImageViewState = setSharedElementState(sharedElementState, sharedElementSnapshots); requestLayoutForSharedElements(); ... setGhostVisibility(View.INVISIBLE); scheduleGhostVisibilityChange(View.INVISIBLE); pauseInput(); // 开始动画 Transition transition = beginTransition(decorView, startEnterTransition, startSharedElementTransition); scheduleGhostVisibilityChange(View.VISIBLE); setGhostVisibility(View.VISIBLE); ... // 将Views设置为原始状态，触发Transition 捕获起始状态&amp;创建/执行动画 setOriginalSharedElementState(mSharedElements, originalImageViewState); ...&#125; 调整Shared Views为Activity A上的初始状态从上面的代码可以看到首先调用了setSharedElementState方法，该方法将Shared Views通过传递来的bundle调整为初始状态，返回的originalImageViewState是Shared Views在Activity B中的原始状态，也就是动画的结束状态，用于后续的恢复。123456789101112131415161718192021222324// EnterTransitionCoordinator.javaprotected ArrayList&lt;SharedElementOriginalState&gt; setSharedElementState( Bundle sharedElementState, final ArrayList&lt;View&gt; snapshots) &#123; ArrayList&lt;SharedElementOriginalState&gt; originalImageState = new ArrayList&lt;SharedElementOriginalState&gt;(); if (sharedElementState != null) &#123; Matrix tempMatrix = new Matrix(); RectF tempRect = new RectF(); final int numSharedElements = mSharedElements.size(); for (int i = 0; i &lt; numSharedElements; i++) &#123; View sharedElement = mSharedElements.get(i); String name = mSharedElementNames.get(i); SharedElementOriginalState originalState = getOldSharedElementState(sharedElement, name, sharedElementState); originalImageState.add(originalState); setSharedElementState(sharedElement, name, sharedElementState, tempMatrix, tempRect, null); &#125; &#125; if (mListener != null) &#123; mListener.onSharedElementStart(mSharedElementNames, mSharedElements, snapshots); &#125; return originalImageState;&#125; 方法内部其实就是遍历所有的Shared View，针对每个View先获取oldState保存，然后设置为动画初始状态。在getOldSharedElementState内部只是简单的保存了left/top等信息，我们着重看一下将View设置为初始状态的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// EnterTransitionCoordinator.javaprivate void setSharedElementState(View view, String name, Bundle transitionArgs, Matrix tempMatrix, RectF tempRect, int[] decorLoc) &#123; // 这里省略针对ImageView的特殊处理 ... float left = sharedElementBundle.getFloat(KEY_SCREEN_LEFT); float top = sharedElementBundle.getFloat(KEY_SCREEN_TOP); float right = sharedElementBundle.getFloat(KEY_SCREEN_RIGHT); float bottom = sharedElementBundle.getFloat(KEY_SCREEN_BOTTOM); if (decorLoc != null) &#123; left -= decorLoc[0]; top -= decorLoc[1]; right -= decorLoc[0]; bottom -= decorLoc[1]; &#125; else &#123; // Find the location in the view's parent getSharedElementParentMatrix(view, tempMatrix); tempRect.set(left, top, right, bottom); tempMatrix.mapRect(tempRect); float leftInParent = tempRect.left; float topInParent = tempRect.top; // Find the size of the view view.getInverseMatrix().mapRect(tempRect); float width = tempRect.width(); float height = tempRect.height(); // Now determine the offset due to view transform: view.setLeft(0); view.setTop(0); view.setRight(Math.round(width)); view.setBottom(Math.round(height)); tempRect.set(0, 0, width, height); view.getMatrix().mapRect(tempRect); left = leftInParent - tempRect.left; top = topInParent - tempRect.top; right = left + width; bottom = top + height; &#125; int x = Math.round(left); int y = Math.round(top); int width = Math.round(right) - x; int height = Math.round(bottom) - y; int widthSpec = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int heightSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); view.layout(x, y, x + width, y + height);&#125; 这里又涉及到一些矩阵知识了，首先是拿到Activity A传过来的View的left/top/right/bottom参数(在屏幕上的)，这里我们是不能直接设置给Activity B的View，因为Activity B的View依赖于它的Parent，所以我们首先将屏幕上的坐标转换为在Parent中的坐标，通过getSharedElementParentMatrix(view, tempMatrix)来拿到转换的Matrix对tempRect进行转换，我们看看getSharedElementParentMatrix的实现1234567891011121314151617181920// EnterTransitionCoordinator.javaprivate void getSharedElementParentMatrix(View view, Matrix matrix) &#123; final int index = mSharedElementParentMatrices == null ? -1 : mSharedElements.indexOf(view); if (index &lt; 0) &#123; matrix.reset(); ViewParent viewParent = view.getParent(); if (viewParent instanceof ViewGroup) &#123; // Find the location in the view's parent ViewGroup parent = (ViewGroup) viewParent; parent.transformMatrixToLocal(matrix); matrix.postTranslate(parent.getScrollX(), parent.getScrollY()); &#125; &#125; else &#123; // The indices of mSharedElementParentMatrices matches the // mSharedElement matrices. Matrix parentMatrix = mSharedElementParentMatrices.get(index); matrix.set(parentMatrix); &#125;&#125; 通过调用Parent的transformMatrixToLocal方法来获得转换矩阵，这和之前提到的transformMatrixToGlobal方法实现非常相似，这里说结论，transformMatrixToLocal返回的Matrix和transformMatrixToGlobal相反，一般返回的Matrix如下所示(除去View自身Matrix的影响的话) $$ \left\{ \begin{matrix} 1 & 0 & -leftOnScreen \\ 0 & 1 & -topOnScreen \\ 0 & 0 & 1 \\ \end{matrix} \right\} $$ 其中leftOnScreen和topOnScreen就是该Parent距离屏幕的左/上的距离。经过此Matrix转换后tempRect的坐标就是我们所期望的View在Parent中的坐标了，但是仍然不能直接设置给View！如果假设View本身设置过Scale=2，那么当将计算后的坐标设置给View时会在正常大小上再作用一个Scale=2，显示的效果就是预期的两倍，所以我们还需要以下操作： 计算我们需要设置的真正width/height：通过拿到View的逆矩阵应用到tempRect上可以得到我们实际需要设置的width/height 计算真正的left/top：之前我们已经计算出视觉上我们的View在Parent中的left和top，但是因为View自身的Matrix影响，我们需要计算出该矩阵应用于矩形后会导致矩形的left/top相比原来偏移多少，然后在设置left/top的时候减去这个偏差调整Shared Views为最终状态共享元素动画使用的是Transition框架，我们只要调整View的状态，就可以自动捕获初始状态/结束状态来生成动画，所以后面要做的就是将SharedViews调整成最初的状态(也就是在Activity B中的最终状态)。从上面的startSharedElementTransition实现来看，首先调用beginTransition方法，内部调用了TransitionManager.beginDelayedTransition(decorView, transition)来开始动画，随后调用setOriginalSharedElementState(mSharedElements, originalImageViewState)来将Shared Views设置为最终状态，我们来看下这个方法的实现123456789101112131415161718// EnterTransitionCoordinator.javaprotected static void setOriginalSharedElementState(ArrayList&lt;View&gt; sharedElements, ArrayList&lt;SharedElementOriginalState&gt; originalState) &#123; for (int i = 0; i &lt; originalState.size(); i++) &#123; View view = sharedElements.get(i); SharedElementOriginalState state = originalState.get(i); // 忽略对ImageView的特殊处理 ... view.setElevation(state.mElevation); view.setTranslationZ(state.mTranslationZ); int widthSpec = View.MeasureSpec.makeMeasureSpec(state.mMeasuredWidth, View.MeasureSpec.EXACTLY); int heightSpec = View.MeasureSpec.makeMeasureSpec(state.mMeasuredHeight, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); view.layout(state.mLeft, state.mTop, state.mRight, state.mBottom); &#125;&#125; originState就是之前调用setSharedElementState返回的原始状态，我们就是通过这个state来恢复View的状态的，实现就只是简单的measure、layout。 参与动画的元素是怎么能够保证不被遮挡的看到这里其实可以知道一点，参与动画的元素都是Activity B上的View，从A过渡过来的效果不过是将B上的View进行转换而已，但是B上的View都是依赖于它的Parent，而动画的初始状态的位置又不能保证在该Parent的可视区域内，按照正常流程，Shared Views很大概率是会在动画过程中移动到不可见区域导致View不可见，所以我们需要将Shared Views移动到屏幕顶层，也就是ViewGroupOverlay层。 GhostView我们直接使用ViewGroupOverlay会有一个问题，ViewGroupOverlay#add(View v)方法会将view从原有的Parent中remove，再添加到ViewGroupOverlay中，可是我们并不希望改变View原有的层级结构，毕竟动画结束后所有View需要恢复原样，所以Android提供了GhostView对ViewOverlay进行了封装，通过调用GhostViet#addGhost方法来将View添加到ViewOverlay层，且能够保持原来的View不变。1234567891011121314// GhostView.java@Overrideprotected void onDraw(Canvas canvas) &#123; if (canvas instanceof DisplayListCanvas) &#123; DisplayListCanvas dlCanvas = (DisplayListCanvas) canvas; mView.mRecreateDisplayList = true; RenderNode renderNode = mView.updateDisplayListIfDirty(); if (renderNode.isValid()) &#123; dlCanvas.insertReorderBarrier(); // enable shadow for this rendernode dlCanvas.drawRenderNode(renderNode); dlCanvas.insertInorderBarrier(); // re-disable reordering/shadows &#125; &#125;&#125; 其实GhostView添加到ViewOverlay的并不是原来的View，而是自己创建的FrameLayout，然后在绘制的时候获取View的renderNode来对自己的canvas进行绘制，达到视觉上和View一摸一样的目的，并且每次View有改变都会通知到GhostView来绘制 使用GhostView后如何保证添加到ViewGroupOverlay的元素与不添加之前层级保持一致我们使用GhostView的时候是将各个View加到Overlay上，但是GhostView是怎么保证View在视觉上的顺序和View在正常布局中的顺序一致的呢？我们发现GhostView#add方法中这么两行代码12int firstGhost = moveGhostViewsToTop(overlay.mOverlayViewGroup, tempViews);insertIntoOverlay(overlay.mOverlayViewGroup, parent, ghostView, tempViews, firstGhost); 由于获得的ViewOverlay中可能存在其他地方加进来的View，所以首先通moveGhostViewsToTop方法遍历其中所有的View，然后将所有GhostView重新add到ViewOverlay中保证GhostView覆盖在最上层。随后就是真正的add操作了，insertIntoOverlay内部其实是通过二分法来找到View插入的index，判断依据是View是否会被绘制在被比较View的上方，通过isOnTop方法来判断123456789101112131415161718192021222324252627// GhostView.java// 通过两个View的Paren队列来判断前者是否在后者上方private static boolean isOnTop(ArrayList&lt;View&gt; viewParents, ArrayList&lt;View&gt; comparedWith) &#123; if (viewParents.isEmpty() || comparedWith.isEmpty() || viewParents.get(0) != comparedWith.get(0)) &#123; // Not the same decorView -- arbitrary ordering return true; &#125; int depth = Math.min(viewParents.size(), comparedWith.size()); for (int i = 1; i &lt; depth; i++) &#123; View viewParent = viewParents.get(i); View comparedWithParent = comparedWith.get(i); if (viewParent != comparedWithParent) &#123; // i - 1 is the same parent, but these are different children. // 走到这说明两者在同一个View的层级下，那么根据在Parent中的顺序来判断 return isOnTop(viewParent, comparedWithParent); &#125; &#125; // 走到这说明两者截取长度为depth的Parent队列一摸一样， // 说明真实队列较长的View是另一个View的Child(或者是另一个View同级的View的child)，也就说明在屏幕上更加靠前 // one of these is the parent of the other boolean isComparedWithTheParent = (comparedWith.size() == depth); return isComparedWithTheParent;&#125; 具体实现是将两个View的Parent队列(包括本身)做比较，首先将较长队列截取为长度和较短队列一致，然后遍历比较，会出现以下两种情况 截取后的两个队列一摸一样：那么较长的队列的View必然是另一队列View的child，自然比parent更加靠上 截取后的两个队列在某一节点开始不一样：那么只要判断这两个节点的层级就可以了，通过调用isOnTop(View, View)来判断123456789101112131415161718192021222324252627282930private static boolean isOnTop(View view, View comparedWith) &#123; ViewGroup parent = (ViewGroup) view.getParent(); final int childrenCount = parent.getChildCount(); final ArrayList&lt;View&gt; preorderedList = parent.buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; parent.isChildrenDrawingOrderEnabled(); // This default value shouldn't be used because both view and comparedWith // should be in the list. If there is an error, then just return an arbitrary // view is on top. boolean isOnTop = true; for (int i = 0; i &lt; childrenCount; i++) &#123; int childIndex = customOrder ? parent.getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? parent.getChildAt(childIndex) : preorderedList.get(childIndex); if (child == view) &#123; isOnTop = false; break; &#125; else if (child == comparedWith) &#123; isOnTop = true; break; &#125; &#125; if (preorderedList != null) &#123; preorderedList.clear(); &#125; return isOnTop;&#125; 该方法判断两个View绘制层级的逻辑和ViewGroup#dispatchDraw是一样的，有兴趣的同学可以深入研究一下。 动画过程中其余元素的状态如何上文提到除去Shared Views其余可见性为Visible的View都会被添加到mTransitioningViews中，本节我们看看动画过程中这些View的状态是怎么样的。我们从EnterTransitionCoordinator#viewsReady()方法入手123456789101112131415161718192021// EnterTransitionCoordinator.java@Overrideprotected void viewsReady(ArrayMap&lt;String, View&gt; sharedElements) &#123; super.viewsReady(sharedElements); mIsReadyForTransition = true; hideViews(mSharedElements); Transition viewsTransition = getViewsTransition(); if (viewsTransition != null &amp;&amp; mTransitioningViews != null) &#123; removeExcludedViews(viewsTransition, mTransitioningViews); stripOffscreenViews(); hideViews(mTransitioningViews); &#125; if (mIsReturning) &#123; sendSharedElementDestination(); &#125; else &#123; moveSharedElementsToOverlay(); &#125; if (mSharedElementsBundle != null) &#123; onTakeSharedElements(); &#125;&#125; 从实现可以看出首先将mTransitioningViews隐藏，将view的alpha设置为0。真正进行动画是在startSharedElementTransition方法中进行，其中调用了beginTransition方法开始真正的动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// EnterTransitionCoordinator.javaprivate Transition beginTransition(ViewGroup decorView, boolean startEnterTransition, boolean startSharedElementTransition) &#123; Transition sharedElementTransition = null; // 忽略共享元素动画 ... Transition viewsTransition = null; if (startEnterTransition) &#123; mIsViewsTransitionStarted = true; if (mTransitioningViews != null &amp;&amp; !mTransitioningViews.isEmpty()) &#123; viewsTransition = configureTransition(getViewsTransition(), true); &#125; if (viewsTransition == null) &#123; viewsTransitionComplete(); &#125; else &#123; final ArrayList&lt;View&gt; transitioningViews = mTransitioningViews; viewsTransition.addListener(new ContinueTransitionListener() &#123; @Override public void onTransitionStart(Transition transition) &#123; mEnterViewsTransition = transition; if (transitioningViews != null) &#123; showViews(transitioningViews, false); &#125; super.onTransitionStart(transition); &#125; @Override public void onTransitionEnd(Transition transition) &#123; mEnterViewsTransition = null; transition.removeListener(this); viewsTransitionComplete(); super.onTransitionEnd(transition); &#125; &#125;); &#125; &#125; Transition transition = mergeTransitions(sharedElementTransition, viewsTransition); if (transition != null) &#123; transition.addListener(new ContinueTransitionListener()); if (startEnterTransition) &#123; setTransitioningViewsVisiblity(View.INVISIBLE, false); &#125; TransitionManager.beginDelayedTransition(decorView, transition); if (startEnterTransition) &#123; setTransitioningViewsVisiblity(View.VISIBLE, false); &#125; decorView.invalidate(); &#125; else &#123; transitionStarted(); &#125; return transition;&#125; 可以看出其余的View的动画是通过getEnterTransition获得的，和Shared Transition同时进行，但是该方法传入了一个参数来判断是否进行enterTransition，该参数在startSharedElementTransition获得1234567// EnterTransitionCoordinator.javaboolean startEnterTransition = allowOverlappingTransitions() &amp;&amp; !mIsReturning;private boolean allowOverlappingTransitions() &#123; return mIsReturning ? getWindow().getAllowReturnTransitionOverlap() : getWindow().getAllowEnterTransitionOverlap();&#125; 通过window#getAllowEnterTransitionOverlap()来判断是否进行enterTransition，该方法表示是否允许enterTransition尽可能早的执行，如果为True将和Shared Transition一起进行，如果为false呢？那么就会在EnterTransitionCoordinator#onRemoteExitTransitionComplete方法中被触发执行，该方法是被ExitTransitionCoordiantor通过notifyComplete触发的123456protected void notifyComplete() &#123; ... mResultReceiver.send(MSG_TAKE_SHARED_ELEMENTS, mSharedElementBundle); notifyExitComplete(); ...&#125; 可见在EnterTransitionCoordinator执行Shared Transition动画后立马触发EnterTransition的动画(如果EnterTransitionOverlap为false)，视觉上差别不会很大 默认的动画是在哪里设置的无论是共享元素动画还是EnterTransition都是从Window中获取的，我们并没有手动设置也可以生效，那是因为Window在加载的时候默认加载了动画12345678// PhoneWindow.javaprivate void installDecor() &#123; ... mEnterTransition = getTransition(mEnterTransition, null, R.styleable.Window_windowEnterTransition); ... mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null, R.styleable.Window_windowSharedElementEnterTransition); ...&#125; 可见是通过windowEnterTransition/windowSharedElementEnterTransition来获取的，在sdk/platforms/android-28/data/res/values/themes_material.xml文件中找到定义123456&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;changeBounds/&gt; &lt;changeTransform/&gt; &lt;changeClipBounds/&gt; &lt;changeImageTransform/&gt;&lt;/transitionSet&gt; 可以看出默认的Shared Transition是四个Transition的集合，其中默认支持ImageView的tranform。 其余元素在动画过程中被Shared Views覆盖怎么办从最开始的Demo 录屏可以看出Activity B左下角的Button展示后会被参与共享元素动画的背景封面遮挡，动画结束后才再次显示出来，这是因为Shared Views都被显示到ViewGroupOverlay中了，所以会覆盖Button，动画结束后回到正常的View层级中Button才能显示。为了解决这个问题我们可以将Button也加入到共享元素中去，这样Button也会显示到ViewOverlay中，就不会被覆盖了。 怎么将View加入到共享元素中去如果我们使用之前的办法，给Button加上transitionName，会发现行不通，因为在收集Shared View的时候会针对Activity A传递过来的name来做去重123456789// EnterTransitionCoordinator.javaprotected void viewsReady(ArrayMap&lt;String, View&gt; sharedElements) &#123; // 将sharedElements中不存在于mAllSharedElementNames中的元素删除 sharedElements.retainAll(mAllSharedElementNames); if (mListener != null) &#123; mListener.onMapSharedElements(mAllSharedElementNames, sharedElements); &#125; ...&#125; 但是我们可以发现后面又调用了mListener#onMapSharedElements方法来添加Shared Views，该Listener类型为SharedElementCallback，我们可以通过activity来设置Listener并重写onMapSharedElements方法12345678910setEnterSharedElementCallback(object : SharedElementCallback() &#123; override fun onMapSharedElements( names: MutableList&lt;String&gt;?, sharedElements: MutableMap&lt;String, View&gt;? ) &#123; super.onMapSharedElements(names, sharedElements) // 将Button加入SharedViews，避免被遮盖 sharedElements?.put("button", button) &#125;&#125;) 这样就可以达到将Button加入到SharedElement中去的目的了，viewsReady中随后会调用moveSharedElementsToOverlay()将SharedView显示到ViewOverlay中去。 Button会参与共享元素动画吗结论是不会，它只会在共享元素动画结束后和其余View一样通过调用moveSharedElementsFromOverlay()返回到正常布局中去。通过之前的分析可以知道是通过setSharedElementState方法将View设置为初始状态的，在该方法中首先通过transitinName从Activity A传递过来的bundle中获取参数，如果获取不到就直接return。Button是我们强行加入的，Activity A传递的bundle中自然没有，所以Button不会做任何改变，效果如下 返回动画的流程返回和进入的核心流程很相似，但是更加简单。首先我们需要调用Activity#finishAfterTransition()方法来触发返回的动画，其内部调用了ActivityTransitionState#startExitBackTransition()方法 12345678910111213141516171819202122232425public boolean startExitBackTransition(final Activity activity) &#123; if (mEnteringNames == null || mCalledExitCoordinator != null) &#123; return false; &#125; else &#123; if (!mHasExited) &#123; ... mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames, null, null, true); ... if (delayExitBack &amp;&amp; decor != null) &#123; final ViewGroup finalDecor = decor; OneShotPreDrawListener.add(decor, () -&gt; &#123; if (mReturnExitCoordinator != null) &#123; mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData); &#125; &#125;); &#125; else &#123; mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData); &#125; &#125; return true; &#125;&#125; 内部给Activity B创建一个ExitTransitionCoordinator，调用startExit方法12345678910111213141516171819202122232425262728293031public void startExit(int resultCode, Intent data) &#123; if (!mIsExitStarted) &#123; mIsExitStarted = true; pauseInput(); ... moveSharedElementsToOverlay(); if (decorView != null &amp;&amp; decorView.getBackground() == null) &#123; getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; final boolean targetsM = decorView == null || decorView.getContext() .getApplicationInfo().targetSdkVersion &gt;= VERSION_CODES.M; ArrayList&lt;String&gt; sharedElementNames = targetsM ? mSharedElementNames : mAllSharedElementNames; ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(mActivity, this, sharedElementNames, resultCode, data); mActivity.convertToTranslucent(new Activity.TranslucentConversionListener() &#123; @Override public void onTranslucentConversionComplete(boolean drawComplete) &#123; if (!mIsCanceled) &#123; fadeOutBackground(); &#125; &#125; &#125;, options); startTransition(new Runnable() &#123; @Override public void run() &#123; startExitTransition(); &#125; &#125;); &#125;&#125; 通过调用Activity#convertToTranslucent()触发Activity A restart()接收到options，options是通过ActivityOptions#makeSceneTransitionAnimation方法创建，将this传递，并设置isReturning=true。Activity A触发后走的和之前一样的流程到EnterTransitionCoordinator#viewsReady()1234567891011121314151617181920@Overrideprotected void viewsReady(ArrayMap&lt;String, View&gt; sharedElements) &#123; super.viewsReady(sharedElements); mIsReadyForTransition = true; hideViews(mSharedElements); Transition viewsTransition = getViewsTransition(); if (viewsTransition != null &amp;&amp; mTransitioningViews != null) &#123; removeExcludedViews(viewsTransition, mTransitioningViews); stripOffscreenViews(); hideViews(mTransitioningViews); &#125; if (mIsReturning) &#123; sendSharedElementDestination(); &#125; else &#123; moveSharedElementsToOverlay(); &#125; if (mSharedElementsBundle != null) &#123; onTakeSharedElements(); &#125;&#125; 不过由于returning为true，触发sendSharedElementDestination方法，将MSG_SHARED_ELEMENT_DESTINATION发送给Activity B的ExitTransitionCoordinator，ExitTransitionCoordinator开始sharedElementExitBack方法开始返回动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ExitTransitionCoordinator.javaprivate void sharedElementExitBack() &#123; final ViewGroup decorView = getDecor(); if (decorView != null) &#123; decorView.suppressLayout(true); &#125; if (decorView != null &amp;&amp; mExitSharedElementBundle != null &amp;&amp; !mExitSharedElementBundle.isEmpty() &amp;&amp; !mSharedElements.isEmpty() &amp;&amp; getSharedElementTransition() != null) &#123; startTransition(new Runnable() &#123; public void run() &#123; startSharedElementExit(decorView); &#125; &#125;); &#125; else &#123; sharedElementTransitionComplete(); &#125;&#125;private void startSharedElementExit(final ViewGroup decorView) &#123; Transition transition = getSharedElementExitTransition(); transition.addListener(new TransitionListenerAdapter() &#123; @Override public void onTransitionEnd(Transition transition) &#123; transition.removeListener(this); if (isViewsTransitionComplete()) &#123; delayCancel(); &#125; &#125; &#125;); final ArrayList&lt;View&gt; sharedElementSnapshots = createSnapshots(mExitSharedElementBundle, mSharedElementNames); OneShotPreDrawListener.add(decorView, () -&gt; &#123; // preDraw的时候将View设置为Activity A的状态，来触发动画 setSharedElementState(mExitSharedElementBundle, sharedElementSnapshots); &#125;); setGhostVisibility(View.INVISIBLE); scheduleGhostVisibilityChange(View.INVISIBLE); if (mListener != null) &#123; mListener.onSharedElementEnd(mSharedElementNames, mSharedElements, sharedElementSnapshots); &#125; // 开始动画 TransitionManager.beginDelayedTransition(decorView, transition); scheduleGhostVisibilityChange(View.VISIBLE); setGhostVisibility(View.VISIBLE); decorView.invalidate();&#125; 结语本文大致介绍了共享元素动画的流程，且着重解析了底层实现的细节，如果大家想深挖动画流程建议阅读源码。 参考资料Android中ResultReceiver使用Android高阶转场动画-ShareElement完全攻略安卓自定义View进阶-Matrix原理安卓自定义View进阶-Matrix详解图片和视频编辑之Matrix大法好GhostViewViewOverlay 的使用]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin协程]]></title>
    <url>%2F2019%2F03%2F21%2Fkotlin%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[协程是什么 协程实际上是一个轻量级的线程，可以挂起并稍后恢复 kotlin中，协程把异步编程放入库中来简化这类操作。程序逻辑在协程中顺序表述，而底层的库会将其转换为异步操作。库会将相关的用户代码打包成回调，调度其执行到不同的线程，而代码依然像顺序执行那么简单。 协程的优势协程主要是让原来要使用“异步+回调”写出来的复杂代码，简化成看起来是同步的代码，本质上是callback的语法糖。 kotlin标准库提供的基本的元素/操作suspend 关键字Kotlin在1.1版本新增加了 suspend 关键字，可以用来修饰函数或者 lambda 表达式123suspend fun suspendFun(): String &#123;&#125;val suspendLambda1: suspend () -&gt; String = &#123;&#125;val suspendLambda2 = suspend &#123;&#125; 被suspend修饰的方法只能在另一个suspend方法或者一个协程中被调用，suspend表示这个方法是一个可中断挂起的方法 CoroutineContextCoroutineContext是协程的上下文，表示一系列用户自定义的Object，也就是代表代码块执行在哪个场景123456interface CoroutineContext &#123; operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R operator fun plus(context: CoroutineContext): CoroutineContext fun minusKey(key: Key&lt;*&gt;): CoroutineContext&#125; get：获取当前指定Key对应的Context fold：类似集合的fold方法，用于累加 plus：重载操作符plus，使得context之间可以用’+’符号运算获得一个新的context minusKey：获得除指定Key对应的Context之外的所有Context Continuation表示协程中的执行单元1234public interface Continuation&lt;in T&gt; &#123; public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;)&#125; ContinuationInterceptorContinuation的拦截器，继承自CoroutineContext，如果当协程的Context包含ContinuationInterceptor那么当前协程内所有的Continuation在执行前都会经过拦截器的替换。 创建和启动协程创建协程的方式很简单，我们需要一个suspend lambda和一个Continuation，标准库为suspend lambda定义了扩展方法startCoroutine12345public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine( completion: Continuation&lt;T&gt;) &#123; createCoroutineUnintercepted(completion).intercepted().resume(Unit)&#125; 该方法创建并启动一个协程，该协程的Context由传入的Continuation提供，且lambda执行完毕后回调该Continuation的resumeWith方法 挂起/恢复协程通过在一个协程中调用标准库提供的suspendContinue方法来挂起当前协程123456public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T = suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt; val safe = SafeContinuation(c.intercepted()) block(safe) safe.getOrThrow() &#125; 该方法接受一个参数为Continuation的lambda，开始执行该lambda并挂起当前协程，如果想要恢复协程的执行，通过调用传入的Continuation的resumeWith方法来恢复 Kotlinx提供的协程库12implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.1'implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.1' 对基础库协程的封装，提供更加简洁的api12345678910GlobalScope.launch(Dispatchers.Main) &#123; launch &#123; delay(1000) Log.d("Debug", "launch 1") &#125; launch &#123; delay(100) Log.d("Debug", "launch 2") &#125;&#125; 原理可挂起的方法采用CPS(Continuation-Passing-Style)实现，每一个可挂起的方法被调用的时候都会被隐式的传递一个Continuation参数来表示后续的操作。 采用Continuation则是一种函数调用方式，它不采用堆栈来保存上下文，而是把这些信息保存在continuation record中。这些continuation record和堆栈的activation record的区别在于，它不采用后入先出的线性方式，所有record被组成一棵树（或者图），从一个函数调用另一个函数就等于给当前节点生成一个子节点，然后把系统寄存器移动到这个子节点。一个函数的退出等于从当前节点退回到父节点。最大的好处就是，它可以让你从任意一个节点跳到另一个节点。而不必遵循堆栈方式的一层一层的return方式。比如说，在当前的函数内，你只要有一个其它函数的节点信息，完全可以选择return到那个函数，而不是循规蹈矩地返回到自己的调用者。你也可以在一个函数的任何位置储存自己的上下文信息，然后，在以后某个适当的时刻，从其它的任何一个函数里面返回到自己现在的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041val a = a()val y = foo(a).await() // suspension point #1b()val z = bar(a, y).await() // suspension point #2c(z)class &lt;anonymous_for_state_machine&gt; extends SuspendLambda&lt;...&gt; &#123; // The current state of the state machine int label = 0 // local variables of the coroutine A a = null Y y = null void resumeWith(Object result) &#123; if (label == 0) goto L0 if (label == 1) goto L1 if (label == 2) goto L2 else throw IllegalStateException() L0: // result is expected to be `null` at this invocation a = a() label = 1 result = foo(a).await(this) // 'this' is passed as a continuation if (result == COROUTINE_SUSPENDED) return // return if await had suspended execution L1: // external code has resumed this coroutine passing the result of .await() y = (Y) result b() label = 2 result = bar(a, y).await(this) // 'this' is passed as a continuation if (result == COROUTINE_SUSPENDED) return // return if await had suspended execution L2: // external code has resumed this coroutine passing the result of .await() Z z = (Z) result c(z) label = -1 // No more steps are allowed return &#125; &#125; ViewModel支持的协程https://craigrussell.io/2019/03/coroutine-support-in-viewmodels-using-the-new-viewmodelscope-extension-property/ 参考资料https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-contexthttps://www.cnblogs.com/cheukyin/p/6444860.html]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为其他对象提供一种代理以控制对这个对象的访问 应用场景 远程代理：也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实(Binder机制)。 保护代理：用来控制真实对象访问时的权限。 智能引用代理：当调用目标对象时，代理可以处理其他的一些操作。 UML类图 静态代理在编写代码期间为每个被代理的对象编写对应的代理类，达到对应的代理功能 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StaticProxy &#123; public static void main(String... args) &#123; RealStudent student = new RealStudent(); IStudent s = new StudentProxy(student); s.doHomework(); &#125; interface IStudent &#123; void doHomework(); &#125; /** * 被代理类，真正的执行者 */ static class RealStudent implements IStudent &#123; @Override public void doHomework() &#123; System.out.println("doing homework..."); &#125; &#125; /** * 代理类 */ static class StudentProxy implements IStudent &#123; private IStudent realStudent; public StudentProxy(IStudent realStudent) &#123; this.realStudent = realStudent; &#125; @Override public void doHomework() &#123; if (realStudent != null) &#123; realStudent.doHomework(); &#125; else &#123; // do nothing &#125; &#125; &#125;&#125; 实例：WeakHandler 优点：在编译期加入，提前就指定好了谁调用谁，效率高。缺点：如果要想为多个类进行代理，则需要建立多个代理类，维护难度加大。 动态代理由于每一个静态代理类只能为一个接口服务，工程中有可能产生很多代理类，所以我们就会想办法可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DynamicProxy &#123; public static void main(String... args) &#123; RealStudent student = new RealStudent(); Class&lt;?&gt;[] inters = new Class[]&#123;IStudent.class&#125;; IStudent s = (IStudent) Proxy.newProxyInstance(student.getClass().getClassLoader(), inters, new StudentProxy(student)); s.doHomework(); &#125; interface IStudent &#123; void doHomework(); &#125; /** * 被代理类，真正的执行者 */ static class RealStudent implements IStudent &#123; @Override public void doHomework() &#123; System.out.println("doing homework..."); &#125; &#125; /** * 代理类 */ static class StudentProxy implements InvocationHandler &#123; private IStudent realStudent; public StudentProxy(IStudent realStudent) &#123; this.realStudent = realStudent; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (realStudent != null) &#123; return method.invoke(realStudent, args); &#125; else &#123; return null; &#125; &#125; &#125;&#125; 动态代理原理：运行时按照Class文件标准格式结合JNI的defineClass0()方法生成Proxy匿名代理类，该类实现了需要代理的接口，并返回这个代理类的实例对象给调用者。12// 保存Proxy生成的中间类到根目录System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true"); 实例：Retrofit 优点：高扩展性缺点： 实现比静态代理复杂，不好理解 要求代理对象必须实现了某个接口]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[仿头条实现EditText的hint上下滚动轮播效果]]></title>
    <url>%2F2018%2F10%2F21%2F%E4%BB%BF%E5%A4%B4%E6%9D%A1%E5%AE%9E%E7%8E%B0EditText%E7%9A%84hint%E4%B8%8A%E4%B8%8B%E6%BB%9A%E5%8A%A8%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[简介最近看到头条的首页顶部搜索框有一个切换hint文字的动画效果，比较好奇它是怎么实现的，经过一番探索发现这个顶部的搜索框并不是真正的搜索框，点击之后是直接跳转到搜索界面，本身并不是一个EditText。这样的实现方式让我顿时感觉索然无味，同时不禁思考，难道不能在一个EditText控件上实现这样的效果吗？百度、google了一番发现并没有找到相关的效果实现，于是决定自己撸一个。起初并没有头绪，后来想起来google官方出的TextInputLayout好像有涉及到EditText的hint动画效果，就研究了一番TextInputLayout的源码，并参考源码实现本文的hint轮播效果。头条与本文实现的效果如下图 原理介绍通过阅读TextInputLayout的源码发现hint的绘制其实不是EditText绘制的，而是TextInpuLayout来进行绘制，它通过获得子控件EditText的hint绘制区域，来自己完成hint相关的绘制与动画操作，而EditText是不设置hint的。有了这个思路，我们就可以开发本文要介绍的控件AutoHintLayout。 实现AutoHintLayoutAutoHintLayout继承自LinearLayout，它需要至少有一个EditText子View，且对外提供一个设置hint的方法来设置hint值并实现切换的动画效果，动画相关的效果我们通过一个AutoHintHelper来集中处理，这样可以避免AutoHintLayout内堆砌太多逻辑。首先我们先定义AutoHintHelper对外提供的方法，具体实现后面详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @author wulinpeng * @description: */public class AutoHintHelper &#123; // AutoHintLayout，用于调用AutoHintLayout的invalidate方法触发刷新布局 private View mView; // 绘制hint的区域 private final Rect mHintBounds = new Rect(); // 上一个hintText private String mLastHintText = ""; // 当前要绘制的hintText private String mHintText = ""; private float mHintTextSize = 15; private ColorStateList mHintTextColor; private Typeface mTypeFace; private int mGravity = Gravity.CENTER_VERTICAL; private int[] state; private Paint mPaint = new Paint(); public AutoHintHelper(View mView) &#123; this.mView = mView; &#125; public void setHintText(String text, boolean anim) &#123; ... &#125; public void setHintTextSize(float mHintTextSize) &#123; ... &#125; public void setHintTextColor(ColorStateList mHintTextColor) &#123; ... &#125; public void setTypeFace(Typeface mTypeFace) &#123; .... &#125; public void setState(int[] state) &#123; .... &#125; public void setGravity(int mGravity) &#123; .... &#125; void setHintBounds(int left, int top, int right, int bottom) &#123; .... &#125; public void showHint(boolean showHint) &#123; .... &#125; /** * AutoHintLayout触发draw方法的时候调用此方法来绘制 */ public void draw(Canvas canvas) &#123; &#125;&#125; 实现AutoHintLayout首先我们要获得EditText绘制hint的相关属性，如颜色、字体、字体大小、Gravity等，在AutoHintLayout的addView方法中我们可以获取到EditText，并将对应的属性设置给AutoHintHelper，实现如下 123456789101112131415161718192021222324252627282930313233343536@Overridepublic void addView(View child, int index, ViewGroup.LayoutParams params) &#123; super.addView(child, index, params); if (child instanceof EditText) &#123; setEditText((EditText) child); &#125;&#125;private void setEditText(EditText editText) &#123; this.mEditText = editText; mAutoHintHelper.setHintTextColor(mEditText.getHintTextColors()); mAutoHintHelper.setHintTextSize(mEditText.getTextSize()); mAutoHintHelper.setTypeFace(mEditText.getTypeface()); mAutoHintHelper.setGravity(mEditText.getGravity()); mEditText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; // 输入字符变化的时候判断是否需要显示hint if (TextUtils.isEmpty(mEditText.getText().toString())) &#123; mAutoHintHelper.showHint(true); &#125; else &#123; mAutoHintHelper.showHint(false); &#125; &#125; &#125;);&#125; 同时我们也给EditText设置了textChanged监听，在EditText输入字符的时候设置不显示hint，反之显示hint。然后我们需要在onLayout方法中给AutoHintHelper设置hint的绘制区域 12345678910111213141516171819202122@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); if (mEditText != null) &#123; final Rect rect = new Rect(); // 获取EditText在本View中的位置 setChildRect(mEditText, rect); l = rect.left + mEditText.getCompoundPaddingLeft(); r = rect.right - mEditText.getCompoundPaddingRight(); // 提供AutoHintHelper hint的绘制区域 mAutoHintHelper.setHintBounds( l, rect.top + mEditText.getCompoundPaddingTop(), r, rect.bottom - mEditText.getCompoundPaddingBottom()); &#125;&#125;void setChildRect(View child, Rect out) &#123; out.set(0, 0, child.getWidth(), child.getHeight()); // 添加child在本布局中的offset到rect offsetDescendantRectToMyCoords(child, out);&#125; 其中setChildRect方法是获取到EditText在AutoHintlayout中的位置，然后加上四边的padding就可以了。最后只要在draw方法中调用AutoHintHelper的draw方法将绘制逻辑交给AutoHintHelper就可以了，当然还需要对外提供一个setHint方法，实现如下 123456789@Overridepublic void draw(Canvas canvas) &#123; super.draw(canvas); mAutoHintHelper.draw(canvas);&#125;public void setHint(String text, boolean anim) &#123; mAutoHintHelper.setHintText(text, anim);&#125; 实现AutoHintHelper主要的动画、绘制逻辑都由这个类实现，首先我们需要确定绘制hint的x和y坐标。EditText的Gravity不同和hint的长度不同会导致绘制hint的x、y坐标不一样（注意这里计算的x、y坐标指的是EditText正常显示hint的坐标，具体动画过程中的y偏移量在draw方法里添加），实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 上一个hint的绘制x坐标private float mLastDrawX;// 当前hint的绘制x坐标 private float mDrawX; // hint的绘制y坐标(上一个和当前的都一样，具体的偏移在ondraw里面计算) private float mDrawY; /** * 根据gravity和paint的参数计算lastHint和当前hint的drawX以及drawY */ private void calculateDrawXY() &#123; float lastHintLength = mPaint.measureText(mLastHintText, 0, mLastHintText.length()); float hintLength = mPaint.measureText(mHintText, 0, mHintText.length()); // 计算x值 switch (mGravity &amp; GravityCompat.RELATIVE_HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: mLastDrawX = mHintBounds.centerX() - (lastHintLength / 2); mDrawX = mHintBounds.centerX() - (hintLength / 2); break; case Gravity.RIGHT: mLastDrawX = mHintBounds.right - lastHintLength; mDrawX = mHintBounds.right - hintLength; break; case Gravity.LEFT: default: mLastDrawX = mDrawX = mHintBounds.left; break; &#125; // 计算y值 switch (mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123; case Gravity.BOTTOM: mDrawY = mHintBounds.bottom; break; case Gravity.TOP: mDrawY = mHintBounds.top - mPaint.ascent(); break; case Gravity.CENTER_VERTICAL: default: float textHeight = mPaint.descent() - mPaint.ascent(); float textOffset = (textHeight / 2) - mPaint.descent(); mDrawY = mHintBounds.centerY() + textOffset; break; &#125; &#125; 然后就是设置一些绘制属性的方法了，每一次更改属性都需要重新计算一遍绘制的坐标 12345678910111213141516171819202122232425262728293031323334353637public void setHintTextSize(float mHintTextSize) &#123; this.mHintTextSize = mHintTextSize; mPaint.setTextSize(mHintTextSize); calculateDrawXY();&#125;public void setHintTextColor(ColorStateList mHintTextColor) &#123; this.mHintTextColor = mHintTextColor;&#125;public void setTypeFace(Typeface mTypeFace) &#123; this.mTypeFace = mTypeFace; mPaint.setTypeface(mTypeFace); calculateDrawXY();&#125;public void setState(int[] state) &#123; this.state = state;&#125;public void setGravity(int mGravity) &#123; this.mGravity = mGravity; calculateDrawXY(); mView.invalidate();&#125;void setHintBounds(int left, int top, int right, int bottom) &#123; Log.d("Debug", "set bounds:" + left + " " + top + " " + right + " " + bottom); if (!rectEquals(mHintBounds, left, top, right, bottom)) &#123; mHintBounds.set(left, top, right, bottom); onBoundsChanged(); &#125;&#125;private void onBoundsChanged() &#123; calculateDrawXY(); mView.invalidate();&#125; 接下来实现setHintText方法，每次外部调用这个方法首先更新hint和lastHint的值，然后开启一个ValueAnimator来开始动画，通过调用mView的invalidate方法触发draw方法绘制当前的hint 12345678910111213141516171819202122232425262728293031323334353637private ValueAnimator mAnimator; private float mCurrentFraction = 0f; private boolean mShowHint = true; private void initAnim() &#123; mAnimator = new ValueAnimator(); mAnimator.setDuration(300); mAnimator.setFloatValues(0f, 1f); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurrentFraction = animation.getAnimatedFraction(); mView.invalidate(); &#125; &#125;); &#125; public void setHintText(String text, boolean anim) &#123; mLastHintText = mHintText; mHintText = text; if (mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; calculateDrawXY(); if (anim) &#123; mCurrentFraction = 0f; mAnimator.start(); &#125; else &#123; mCurrentFraction = 1f; mView.invalidate(); &#125; &#125; public void showHint(boolean showHint) &#123; mShowHint = showHint; mView.invalidate(); &#125; 首先需要将运行中的动画取消，然后重新计算绘制坐标，如果不需要动画则直接设置mCurrentFraction为1，draw的时候将直接绘制当前的hint，不做任何动画，反之开启动画。最后实现最关键的draw方法 123456789101112131415public void draw(Canvas canvas) &#123; if (!mShowHint) &#123; // draw empty return; &#125; mPaint.setColor(state == null? mHintTextColor.getDefaultColor(): mHintTextColor.getColorForState(state, 0)); float boundsHeight = mHintBounds.bottom - mHintBounds.top; float offsetY = boundsHeight * mCurrentFraction; // draw last hint with curr fraction canvas.drawText(mLastHintText, 0, mLastHintText.length(), mLastDrawX, mDrawY - offsetY, mPaint); // draw curr hint with curr fraction canvas.drawText(mHintText, 0, mHintText.length(), mDrawX, boundsHeight + mDrawY - offsetY, mPaint);&#125; 首先通过mCurrentFraction计算出当前的y偏移值，也就是lastHint应该向上滚动的距离，绘制lastHint的时候将mDrawY减去offset就可以了。绘制当前hint的时候需要在lastHint的基础上加上boundsHeight，也就是说新的hint在老的hint下方boundsHeight距离，boundsHeight就是绘制hint区域的高度。 扩展到此就基本实现了hint滚动播放的效果，但是仔细想想，hint的动画只会有这么一种吗？如果我需要别的动画效果呢？我是不是需要重新写对应的XXHintLayout类？这里就要考虑到扩展性，无论什么动画，只要我们提供hint绘制区域、绘制的paint、动画播放进度等信息就可以实现，所以这里抽象出一个接口IAutoHintDrawer来实现具体的绘制方法 12345678/** * @author wulinpeng * @description: hint动画的具体绘制 */public interface IAutoHintDrawer &#123; void draw(Rect drawBounds, float lastDrawX, float drawX, float drawY, float fraction, String lastHint, String currHint, Canvas canvas, Paint paint);&#125; 然后在AutoHintHelper的draw方法中调用IAutoHintDrawer的draw方法来实现，而IAutoHintDrawer的实例由具体的业务方实现然后传入，具体的实现就不赘述了，本项目的代码已经上传到Github，欢迎交流。]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为RecyclerView添加load more功能]]></title>
    <url>%2F2018%2F09%2F23%2F%E4%B8%BARecyclerView%E6%B7%BB%E5%8A%A0loadmore%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[思路实现LoadMore功能主要是从Adapter入手，通过在onAttachedToRecyclerView方法里给RecyclerView添加滑动监听来实现。一种思路是实现一个LoadMoreAdapter基类让其他的Adapter继承来获得load more的能力，但是这样的实现方式感觉有点侵入原有的Adapter代码，而且不够灵活，所以本文采用代理原有Adapter的方式来实现。 实现FooterView第一步先来实现FooterView，我们定义一个FooterView的接口123public interface IFooterView &#123; public void changState(LoadingState state);&#125; 其中LoadingState是load more的状态，有如下几种 123456public enum LoadingState &#123; LOADING_STATE_NO_MORE, // 没有更多 LOADING_STATE_LOADING, // 加载中 LOADING_STATE_ERROR, // 加载错误 LOADING_STATE_NORMAL // 不显示footer&#125; 然后我们实现一个默认的FooterView 123456789101112131415161718192021222324252627282930313233343536373839public class DefaultFooterView extends RelativeLayout implements IFooterView &#123; private ProgressBar mLoadingView; private TextView mNoMoreView; private TextView mErrorView; private LoadMoreAdapter.LoadingState mState = LoadMoreAdapter.LoadingState.LOADING_STATE_NORMAL; public DefaultFooterView(Context context) &#123; this(context, null); &#125; public DefaultFooterView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DefaultFooterView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; initView(); &#125; private void initView() &#123; inflate(getContext(), R.layout.default_footer_layout, this); mLoadingView = (ProgressBar) findViewById(R.id.loading_view); mNoMoreView = (TextView) findViewById(R.id.no_more_view); mErrorView = (TextView) findViewById(R.id.error_view); &#125; @Override public void changState(LoadMoreAdapter.LoadingState state) &#123; mState = state; mLoadingView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_LOADING? VISIBLE: GONE); mNoMoreView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_NO_MORE? VISIBLE: GONE); mErrorView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_ERROR? VISIBLE: GONE); &#125;&#125; 具体的布局就不展示了，各位自由发挥。如上所示，FooterView对外提供changeState方法来改变布局为对应的状态。 实现LoadMoreAdapterLoadMoreAdapter用来代理一个真正的Adapter，将相关的系统回调传递给Adapter并实现load more的功能，而在外部RecyclerView使用LoadMoreAdapter而不是被代理的Adapter。 代理Adapter创建LoadMoreAdapter需要传入一个Adapter，LoadMoreAdapter保存这个Adapter并在相关的系统回调方法里触发Adapter相应的回调，如下所示方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Overridepublic void setHasStableIds(boolean hasStableIds) &#123; super.setHasStableIds(hasStableIds); mAdapter.setHasStableIds(hasStableIds);&#125;@Overridepublic long getItemId(int position) &#123; if (position &gt; mAdapter.getItemCount() - 1) &#123; return super.getItemId(position); &#125; return mAdapter.getItemId(position);&#125;@Overridepublic void onViewRecycled(RecyclerView.ViewHolder holder) &#123; if (holder instanceof FooterViewHolder) &#123; super.onViewRecycled(holder); return; &#125; mAdapter.onViewRecycled(holder);&#125;@Overridepublic boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) &#123; if (holder instanceof FooterViewHolder) &#123; return super.onFailedToRecycleView(holder); &#125; return mAdapter.onFailedToRecycleView(holder);&#125;@Overridepublic void onViewAttachedToWindow(RecyclerView.ViewHolder holder) &#123; if (holder instanceof FooterViewHolder) &#123; super.onViewAttachedToWindow(holder); return; &#125; mAdapter.onViewAttachedToWindow(holder);&#125;@Overridepublic void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) &#123; if (holder instanceof FooterViewHolder) &#123; super.onViewDetachedFromWindow(holder); &#125; mAdapter.onViewDetachedFromWindow(holder);&#125;@Overridepublic void registerAdapterDataObserver(RecyclerView.AdapterDataObserver observer) &#123; super.registerAdapterDataObserver(observer); mAdapter.registerAdapterDataObserver(observer);&#125;@Overridepublic void unregisterAdapterDataObserver(RecyclerView.AdapterDataObserver observer) &#123; super.unregisterAdapterDataObserver(observer); mAdapter.unregisterAdapterDataObserver(observer);&#125; 其中mAdapter.registerAdapterDataObserver(observer);方法必须要写，因为只有这样才会在调用Adapter的notify方法的时候通知到RecyclerView来刷新数据。 实现LoadMoreLoadMoreAdapter内部保存一个当前的state，通过这个state来判断当前是否应该显示footer，主要是通过getItemCount()、getItemViewType()、onCreateViewHolder()、onBindViewHolder()四个方法来实现 12345678910111213141516171819202122232425262728293031@Overridepublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_FOOT) &#123; IFooterView footView = (View) new DefaultFooterView(mContext); return new FooterViewHolder(footView); &#125; return mAdapter.onCreateViewHolder(parent, viewType);&#125;@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof FooterViewHolder) &#123; FooterViewHolder viewHolder = (FooterViewHolder) holder; viewHolder.bind(mState); return; &#125; mAdapter.onBindViewHolder(holder, position);&#125;@Overridepublic int getItemCount() &#123; return mAdapter.getItemCount() + (mState == LoadingState.LOADING_STATE_NORMAL? 0: 1);&#125;@Overridepublic int getItemViewType(int position) &#123; if (position == mAdapter.getItemCount()) &#123; return TYPE_FOOT; &#125; return mAdapter.getItemViewType(position);&#125; 且对外提供一个方法来改变当前的状态 1234567public void updateLoadMoreState(LoadingState state) &#123; if (!checkState(state)) &#123; return; &#125; mState = state; notifyDataSetChanged();&#125; 当然真正的LoadMore逻辑是在onAttachedToRecyclerView的时候给RecyclerView添加滑动监听来实现的，代码如下 1234567891011121314151617181920212223242526272829303132@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); mAdapter.onAttachedToRecyclerView(recyclerView); mRecyclerView = recyclerView; mRecyclerView.addOnScrollListener(mScrollerListener);&#125;private void initScrollListener() &#123; mScrollerListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); boolean showLoadMore = false; showLoadMore = !recyclerView.canScrollVertically(1) &amp;&amp; dy &gt; 0; if (showLoadMore) &#123; if (mLoadMoreListener != null &amp;&amp; mState != LoadingState.LOADING_STATE_LOADING) &#123; mState = LoadingState.LOADING_STATE_LOADING; notifyDataSetChanged(); mLoadMoreListener.onLoadMore(); &#125; &#125; &#125; &#125;;&#125;public interface OnLoadMoreListener &#123; public void onLoadMore();&#125; 在RecyclerView要向上滑动但不能向上滑的时候触发LoadMore(当前不处于loading的时候)，后面就要求外部在加载结束后调用LoadMoreAdapter的updateLoadMoreState方法来更新状态。 实现过程中的坑原来的思路是itemCount写死mAdapter.getItemCount + 1,然后在不现实footer的时候让FooterView内部的View都gone，然后设置高度为0，看起来就相当于没有FooterView。但是RecyclerView貌似会对布局中元素都是gone或者空布局做一些优化，导致canScrollVertically始终返回true，所以后来采用了更改itemCount的方法。]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己动手写一个简单的Android下拉刷新]]></title>
    <url>%2F2018%2F04%2F12%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Android%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[概述一开始的时候尝试通过Android的事件分发机制来实现，但是child一旦消耗事件，那么后续事件是不会传给Parent的，只能重写dispatchTouchEvent来拦截，这样做相当于重写了Android的事件分发机制，我自认水平是不够的。随后阅读了Android官方刷新空间SwipeRefreshLayout，发现是使用的NestedScrolling机制，具体使用可以看鸿洋大神的这篇文章https://blog.csdn.net/lmj623565791/article/details/52204039 所以本篇文章就使用NestedScrolling机制来实现针对RecyclerView的下拉刷新功能，别的控件暂不支持。 实现思路控件本身继承自LinearLayout，有两个child，分别是Header和Content，通过设置Header的TopMargin来控制Header的滑动效果。 实现NestedScrollingParent维护两个变量 12private int mUnConsumedY = 0;private int mHeaderShowHeight = 0; mHeaderShowHeight表示当前Header显示部分的高度，mUnConsumedY表示当前给RecyclerView消费掉的Y距离，通过这个变量来判断RecyclerView是否滑到顶端。 实现onNestedPreScroll方法通过这个方法实现在滑动之前判断应该消费多少Y距离，只有两种情况 向上滑动且mHeaderShowHeight大于0，这时候消费掉dy，不给child消费，同时更新mHeaderShowHeight 向下滑动且mUnConsumedY为0，这时候消费dy。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0 &amp;&amp; mHeaderShowHeight &gt; 0) &#123; // header显示的时候上滑 if (dy &lt;= mHeaderShowHeight) &#123; mHeaderShowHeight -= dy; consumed[1] = dy; &#125; else &#123; consumed[1] = mHeaderShowHeight; mHeaderShowHeight = 0; &#125; &#125; if (dy &lt; 0 &amp;&amp; mUnConsumedY == 0) &#123; consumed[1] = dy; mHeaderShowHeight -= dy; &#125; // 其他情况皆为更新mUnConsumedY，在onNestedScroll方法中更新 Log.d("Debug", mHeaderShowHeight + " " + mUnConsumedY); processHeaderShowHeight(); updateProgress(mHeaderShowHeight);&#125;/** * 处理mHeaderShowHeight，如果高于mHeaderHeight，加一个滑动的阻力 */private void processHeaderShowHeight() &#123; // 计算阻力作用后的mHeaderShowHeight if (mHeaderShowHeight &gt; mHeaderHeight) &#123; int extra = mHeaderShowHeight - mHeaderHeight; // 阻力系数 float dragRatio = mHeaderHeight * 1.0f / mHeaderShowHeight; mHeaderShowHeight = (int) (mHeaderHeight + extra * dragRatio); &#125; // 通过mHeaderShowHeight来设置topMargin setHeaderTopMarginWithShowHeight();&#125;/** * 根据mHeaderShowHeight更新当前进度 * @param mHeaderShowHeight */private void updateProgress(int mHeaderShowHeight) &#123; if (mListener != null) &#123; mListener.onRefreshProgress(mHeaderShowHeight * 1.0f / mHeaderHeight); &#125;&#125; 其他的情况都是RecyclerView滑动，在onNestedScroll中更新mUnConsumedY 实现onNestedScroll方法这个方法更新mUnConsumedY 1234567891011121314/** * 在子view滑动后通过消耗和未消耗的，来计算子view是否滑动到最顶端 * @param target * @param dxConsumed * @param dyConsumed * @param dxUnconsumed * @param dyUnconsumed */@Overridepublic void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); mUnConsumedY += dyConsumed; mUnConsumedY = Math.max(mUnConsumedY, 0);&#125; 实现onStopNestedScroll方法这个方法里判断当前的状态，如果不是正在刷新或者释放刷新状态，都隐藏Header，否则进入刷新状态，判断是否释放刷新状态的阈值通过回调获得，回调下面来说 12345678910111213@Overridepublic void onStopNestedScroll(View child) &#123; super.onStopNestedScroll(child); if (mHeaderShowHeight &gt; 0) &#123; float changeStateRatio = mListener == null? 1.0f : mListener.getChangeStateRatio(); if (mHeaderShowHeight * 1.0f / mHeaderHeight &gt; changeStateRatio) &#123; // 开始刷新 startRefreshing(); &#125; else &#123; stopRefreshing(); &#125; &#125;&#125; 实现onNestedPreFling由于Fling操作会导致mUnConsumedY不能正常更新，所以重写这个方法返回true来禁止child实现这个操作 1234@Overridepublic boolean onNestedPreFling(View target, float velocityX, float velocityY) &#123; return true;&#125; 定义刷新回调12345678910public interface EasyRefreshListener &#123; void onRefreshing(); // 根据progress改变内容 void onRefreshProgress(float progress); // 改变下拉状态的阈值 float getChangeStateRatio();&#125; 结语以上就是大致思路，具体的代码已经上传到Github，后续会完善各项功能]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Button点击时滑动的事件传递]]></title>
    <url>%2F2017%2F11%2F02%2FButton%E7%82%B9%E5%87%BB%E6%97%B6%E6%BB%91%E5%8A%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[背景之前面试的时候遇到一个有关滑动事件的问题，让我十分费解，后来查阅相关资料和源码才得以解决，问的是在一个RecyclerView中，有一个item为Button，如果在按下这个Button的同时进行滑动，Button是否能够保持焦点？相关事件是如何传递的？ 思考按照以往我对事件传递机制的理解，在按下的时候是一个Down事件ViewGroup-&gt;Button，然后滑动的时候就是一系列Move事件，但是由于向上的Move事件会被ViewGroup(RecyclerView)拦截，所以Button就会失去焦点，实验结果也是如此，但是如果ViewGroup真的拦截了Move之后的所有事件，Button是如何得知自己失去焦点并更新UI为失去焦点的UI(至少得获得一个CANCEL或者UP事件吧?)。实验证明却是在Move被拦截后接收到了CANCEL事件，但是这个CANCEL是如何来的呢？ 源码解析在ViewGroup的dispatchTouchEvent方法的最后一部分有这样的代码 12345678910111213141516171819202122232425while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next;&#125; 大致流程是先判断事件是否已经传递给child处理，如果是就返回，如果没有那么就会尝试通过dispatchTransformedTouchEvent给child传递一个CANCEL事件，部分代码如下 12345678910111213141516171819private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ...&#125; 可以看出就是这里给child传递了CANCEL事件]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求二叉树满足条件路径]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[问题给定二叉树，求的某一路径满足所有节点和为某一个值 分析采用递归，定义一个方法List getPath(Node root, int target),从root开始，首先判断root.val是否大于target，如果大于说明这个路径不可能成功，返回一个空的List就可以，如果小，那么target -= val，然后递归左右节点，如果返回的List不空，那么说明满足，就可以add自己进path了。其实递归的实质，就是从叶子结点开始向上计算，所以返回的List应该是从叶子节点创建的，我们在程序中需要特殊判断叶子结点。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;/* public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; */ &#125;public class Solution &#123; public ArrayList&lt;Integer&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;Integer&gt; data = new ArrayList&lt;&gt;(); // 非法节点,返回空list if (root == null || root.val &gt; target) &#123; return data; &#125; // 叶子结点 if (root.left == null &amp;&amp; root.right == null) &#123; // 不满足，返回空list if (root.val != target) &#123; return data; &#125; // 满足就add，返回 data.add(root.val); return data; &#125; // 普通节点 target -= root.val; ArrayList&lt;Integer&gt; l = FindPath(root.left, target); if (l.size() != 0) &#123; // 返回非空，满足 l.add(root.val); return l; &#125; ArrayList&lt;Integer&gt; r = FindPath(root.right, target); if (r.size() != 0) &#123; // 返回非空，满足 r.add(root.val); return r; &#125; // 左右节点均不满足,返回空list return data; &#125;&#125; 扩展前面我们只需要找到一条就可以了，但是如果要求我们找到所有呢？思路其实一样，只不过变成List]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NestedScrolling详解]]></title>
    <url>%2F2017%2F06%2F18%2FNestedScrolling%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介假设我们需要一个这样的效果，拖动子View的时候需要parent先滑动，等parent滑倒顶端的时候再让子View滑动。Android事件分发机制在parent处理事件的时候，没法再次把事件传递给子View（除非再来一个Down，开启一个新的事件序列），所以就需要用到NestedScrolling，也就是嵌套滑动机制。今天我们来实现如下效果蓝色部分是子View，粉色是Parent，在向上滑动时，保证Parent首先滑动到顶端，向下滑动时保证子View首先滑倒底部。 基本类和方法这里需要用到两个接口 12NestedScrollingChildNestedScrollingParent 和两个辅助类 12NestedScrollingChildHelperNestedScrollingParentHelper NestedScrollingChild子View实现这个接口 12345678910111213141516171819public void setNestedScrollingEnabled(boolean enabled);public boolean isNestedScrollingEnabled();public boolean startNestedScroll(int axes);public void stopNestedScroll();public boolean hasNestedScrollingParent();public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);public boolean dispatchNestedPreFling(float velocityX, float velocityY); void setNestedScrollingEnabled(boolean enabled)：允许嵌套滑动 boolean startNestedScroll(int axes)：一般在ACTION_DOWN的事件里调用，表示要开始滑动，axes代表方向，有SCROLL_AXIS_VERTICAL、SCROLL_AXIS_HORIZONTAL两种 boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)：一般在ACTION_MOVE种调用，dx、dy是将要滑动的量，然后分发给Parent让他消耗，consumed是一个二维数组，分别存储Parent消耗的x、y方向上的量，如果无消耗那么返回false。 NestedScrollingParentParent实现这个接口 12345678910111213141516public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);public void onStopNestedScroll(View target);public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);public boolean onNestedPreFling(View target, float velocityX, float velocityY);public int getNestedScrollAxes(); void onNestedPreScroll(View target, int dx, int dy, int[] consumed)：子View调用dispatchNestedPreScroll的时候此方法会被回调，通过判断dx、dy来计算消耗，返回消耗值。 然而真正的逻辑实现都由Helper类帮我们实现了，我们只需要调用helper类的对应方法即可，接下来开始写代码。 ChildView代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * @author wulinpeng * @datetime: 17/6/17 下午10:34 * @description: */public class ChildView extends View implements NestedScrollingChild &#123; private NestedScrollingChildHelper helper; private float lastY = 0; private int[] consume = new int[2]; private int[] offset = new int[2]; public ChildView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; helper = new NestedScrollingChildHelper(this); helper.setNestedScrollingEnabled(true); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: lastY = event.getY(); // 开始垂直的滑动 helper.startNestedScroll(SCROLL_AXIS_VERTICAL); break; case MotionEvent.ACTION_MOVE: // 获得滑动量 int dy = (int) (event.getY() - lastY); if (dy &lt; 0) &#123; // 向上滑动的逻辑，保证parent消耗，才到自己 if (!helper.dispatchNestedPreScroll(0, (int) dy, consume, offset)) &#123; // 运行到这说明parent不消耗了，parent已经到达顶部，这时候自身滑动 // 因为向上滑动dy &lt; 0，所以*－1方便比较 int space = (int) getY() * -1; int consumeY = Math.max(space, dy); setY(getY() + consumeY); &#125; &#125; else &#123; // 向下滑动的逻辑，保证自己消耗，才到parent int space = (int) (((ParentView) getParent()).getHeight() - getY() - getHeight()); int consumeY = Math.min(space, dy); dy -= consumeY; setY(getY() + consumeY); // 自己消耗完后，然后传给Parent剩下的dy－consumeY helper.dispatchNestedPreScroll(0, (int) dy, consume, offset); &#125; break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; @Override public void setNestedScrollingEnabled(boolean enabled) &#123; helper.setNestedScrollingEnabled(enabled); &#125; @Override public boolean isNestedScrollingEnabled() &#123; return helper.isNestedScrollingEnabled(); &#125; @Override public boolean startNestedScroll(int axes) &#123; return helper.startNestedScroll(axes); &#125; @Override public void stopNestedScroll() &#123; helper.stopNestedScroll(); &#125; @Override public boolean hasNestedScrollingParent() &#123; return helper.hasNestedScrollingParent(); &#125; @Override public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) &#123; final boolean b = helper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow); return b; &#125; @Override public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) &#123; final boolean b = helper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow); return b; &#125; @Override public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) &#123; return helper.dispatchNestedFling(velocityX, velocityY, consumed); &#125; @Override public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123; return helper.dispatchNestedPreFling(velocityX, velocityY); &#125;&#125; 注释比较清楚了，主要就是方向不同逻辑不同，向上的时候先分发给Parent，如果Parent不消耗了（返回false，也就是说到达顶部了），那么自己消耗dy（向上滑动，注意越界情况）；向下的时候，首先自己向下滑动（自己消耗dy），然后给Parent分发消耗后的dy。 ParentView代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @author wulinpeng * @datetime: 17/6/17 下午10:37 * @description: */public class ParentView extends FrameLayout implements NestedScrollingParent &#123; private NestedScrollingParentHelper helper; public ParentView(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; helper = new NestedScrollingParentHelper(this); &#125; @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; FrameLayout parent = (FrameLayout) getParent(); if (dy &gt; 0) &#123; // 向下滑动 int space = (int) (parent.getHeight() - getY() - getHeight()); int consumeY = Math.min(dy, space); consumed[1] = consumeY; setY(getY() + consumeY); &#125; else &#123; // 向上滑动 int space = (int) (getY() * -1); int consumeY = Math.max(dy, space); consumed[1] = consumeY; setY(getY() + consumeY); &#125; &#125; @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) &#123; return true; &#125; @Override public boolean onNestedPreFling(View target, float velocityX, float velocityY) &#123; return true; &#125; @Override public int getNestedScrollAxes() &#123; return helper.getNestedScrollAxes(); &#125; @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; return true; &#125; @Override public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes) &#123; helper.onNestedScrollAccepted(child, target, nestedScrollAxes); &#125; @Override public void onStopNestedScroll(View target) &#123; helper.onStopNestedScroll(target); &#125; @Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; &#125;&#125; 比较简单，主要是注意越界的情况，接下来只要在布局文件里将ChildView设置为ParentView的child就可以了。 源码解析但是这两者到底是怎么样联系起来的呢？我们看看Helper类的源码 12345678910111213141516171819202122public boolean startNestedScroll(int axes) &#123; if (hasNestedScrollingParent()) &#123; // Already in progress return true; &#125; if (isNestedScrollingEnabled()) &#123; ViewParent p = mView.getParent(); View child = mView; while (p != null) &#123; if (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123; mNestedScrollingParent = p; ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes); return true; &#125; if (p instanceof View) &#123; child = (View) p; &#125; p = p.getParent(); &#125; &#125; return false;&#125; startNestedScroll是最开始要调用的，作用就是把这个Child和Paren联系起来，内部首先寻找可用的Parent，然后回调Parent的onStartNestedScroll方法，如果返回true，那么就给内部的mNestedScrollingParent赋值同时回调Parent的onNestedScrollAccepted方法，否则mNestedScrollingParent还是null。如果已经有了Parent那么直接返回true，可以知道这个方法调用一次就可以了，只要和Parent联系起来就ok。 12345678910111213141516171819202122232425262728293031323334public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) &#123; if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) &#123; if (dx != 0 || dy != 0) &#123; int startX = 0; int startY = 0; if (offsetInWindow != null) &#123; mView.getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; &#125; if (consumed == null) &#123; if (mTempNestedScrollConsumed == null) &#123; mTempNestedScrollConsumed = new int[2]; &#125; consumed = mTempNestedScrollConsumed; &#125; consumed[0] = 0; consumed[1] = 0; ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed); if (offsetInWindow != null) &#123; mView.getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; &#125; return consumed[0] != 0 || consumed[1] != 0; &#125; else if (offsetInWindow != null) &#123; offsetInWindow[0] = 0; offsetInWindow[1] = 0; &#125; &#125; return false;&#125; 这个方法首先判断isNestedScrollingEnabled和mNestedScrollingParent，如果mNestedScrollingParent＝＝null也就是Parent在onStartNestedScroll返回了false，那么就不会收到这个分发。方法内部回调了Parent的onNestedPreScroll方法，然后判断consume的两个值，如果都是0，那么说明Parent没有消耗，就返回false表示Parent不消耗。 总结其实就是NestedScrollingChild发出各种事件，比如最开始的startNestedScroll来寻找可用的Parent同时回调Parent的方法，dispatchNestedPreScroll分发偏移量给Parent让它先消耗，而NestedScrollParent只是被动接受各种回调作出处理，比如在onStartNestedScroll返回boolean表示是否接受嵌套滑动，在onNestedPreScroll消耗滑动偏移量。其实高版本的View默认实现了这些方法，但是为了兼容低版本，我们是用Helper来实现，其实实现代码是一样的。]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Toast源码解析]]></title>
    <url>%2F2017%2F05%2F27%2FToast%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[子线程中的Toast在写代码的时候发现一个现象，在子线程中使用Toast会crash，错误如下 1java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() 可以很明显的看出问题出在当前线程企图创建Handler，但是由于本线程没有Looper所以crash了，这时候我不禁对Toast的实现原理产生兴趣，接下来就一步一步的分析源码。 Toast的创建在日常使用中都是使用Toast.makeText()来创建一个Toast，代码如下 1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result;&#125; 其实很简单，就是设置了mNextView和mDuration，创建一个TextView然后设置传入的String就完成mNextView的设置，mDuration参数被@Duration注解标记，注解如下 123456@IntDef(&#123;LENGTH_SHORT, LENGTH_LONG&#125;)@Retention(RetentionPolicy.SOURCE)public @interface Duration &#123;&#125;public static final int LENGTH_SHORT = 0;public static final int LENGTH_LONG = 1; @IntDef限制了只能传入两个给定的int，也就是说我们只能设置显示时间的长短，而无法设置具体的时长。 Toast.show()show()方法源码如下 12345678910111213141516public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 可以看出这里需要得到一个INotificationManager的服务，传入了TN的实例，首先我们先看看TN是什么东西 123private static class TN extends ITransientNotification.Stub &#123; ...｝ 查看ITransientNotification的代码 12345678910public interface ITransientNotification extends android.os.IInterface&#123;/** Local-side IPC implementation stub class. */public static abstract class Stub extends android.os.Binder implements android.app.ITransientNotification&#123;// 省略大部分代码...public void show() throws android.os.RemoteException;public void hide() throws android.os.RemoteException;&#125; 可以看出这就是一个AIDL的接口，有show()和hide()两个办法，可以猜测主要用于远程服务来控制Toast显示和隐藏的。我们就看看show和hide的具体实现 1234567891011121314151617181920212223242526272829final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125;&#125;;final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125;&#125;;@Overridepublic void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.obtainMessage(0, windowToken).sendToTarget();&#125;@Overridepublic void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide);&#125; 这里就用到了Handler，通过Handler实现show和hide，这也就解释了为什么子线程会报错。show()最终调用handlerShow()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public void handleShow(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "HANDLE SHOW: " + this + " mView=" + mView + " mNextView=" + mNextView); if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; mParams.token = windowToken; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; if (localLOGV) Log.v(TAG, "ADD! " + mView + " in " + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125;&#125; 可以看出主要就是通过WindowManager来addView显示Toast。hide()最终调用handleHide方法实现 1234567891011121314public void handleHide() &#123; if (localLOGV) Log.v(TAG, "HANDLE HIDE: " + this + " mView=" + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; mView = null; &#125;&#125; 也是通过WindowManager来removevView。 Toast的时长我们在使用Toast的时候只能穿入LENGTH_LONG活着LENGTH_SHORT两个变量，而具体的时间在handleShow()的代码中可以发现 12mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; 12static final long SHORT_DURATION_TIMEOUT = 5000;static final long LONG_DURATION_TIMEOUT = 1000; 可以看出长短时间分别对应5秒和1秒 为何使用AIDL而不是自己控制显示和隐藏不知道大家有没有发现，在显示两个Toast的时候，总是第一个显示完毕才会显示第二个，如果让Toast自己控制，那么是很难实现这样的效果的，它并不知道其他Toast的状态，所以所有Toast交由系统同意管理，通过队列来依次显示Toast，并会按照设置的时间来hide Toast。 如何自己控制时间我们可以跳过AIDL，获取NT对象，直接调用show和hide方法，但是NT对象构造方法是私有的，我们可以通过反射来解决，当然也可以反射设置time，然后正常show。]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消失的数字]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组a[]，长度为n，保证1&lt;=a[i]&lt;=n,找出1-n中所有未出现的数字，不使用额外空间且时间复杂度为O(n). 思路分析如果可以使用额外空间，我们会使用一块额外空间来记录某一个数字是否出现过，遍历一遍a来更新额外空间状态，然后遍历额外空间来获得未出现的数字。现在不允许使用额外空间，我们可以不可以直接在数组上来保存状态？可以这样做，假设数组长度为n，我们发现a[0]=3，那么说明3出现一次，由于数组下标是0~n-1，所以我们更新下标为2的值来表示3出现一次，怎么更新呢？直接让a[2]+n这样的话每次使用数组都要%n得到实际的值，代码如下123456789101112131415161718public class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int n = nums.length; // 完成此次循环后，nums[i]代表i+1出现的次数 // 通过和将值和n比较，如果大于n说明有出现过i+1的值 // 每次发现一个值，就－1然后和%n防止已经出现多次 for (int i = 0; i != n; ++i) &#123; nums[(nums[i] - 1) % n] += n; &#125; for (int i = 0; i != n; ++i) &#123; if (nums[i] &lt;= n) &#123; result.add(i + 1); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用位运算实现加法]]></title>
    <url>%2F2017%2F03%2F31%2F%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分析求两个整数之和，要求不使用+、-、*、/四则运算符号，那么只能想到用位运算了，其实二进制和十进制的运算是很相似的，都是每一位相加，多出来的进位。以7和3为例，二进制分别是111和101，假设不考虑进位，那么结果就是010，也就是111^101，同时也可以算得进位就是(111&amp;101)&lt;&lt;1，最后就变成了这两个数相加，重复之前的步骤，直到进位是0，就完成了加法。 实现1234567891011public static void main(String[] args) &#123; int num1 = 111, num2 = 899; while (num2 != 0) &#123; // 让num2变成进位，num1就是不考虑进位的值，一直到num2为0，num1就是结果 int temp = num1; num1 = num1 ^ num2; num2 = (temp &amp; num2) &lt;&lt; 1; System.out.println("num1:" + num1 + "num2" + num2); &#125; System.out.println(num1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java匿名内部类使用局部变量]]></title>
    <url>%2F2017%2F03%2F04%2FJava%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在Java8之前，我们在匿名内部类或者局部内部类中使用局部变量都需要将局部变量声明为final，这是因为java底层给我们做了一些小动作，匿名内部类表面上没有构造函数，其实是有的，底层直接将局部变量通过构造函数传给内部类，局部变量在生命周期结束后就会被销毁，而匿名内部类的生命周期一般来说都比局部变量长，那么假如我们可以修改这个变量，就会出现内外不一致的现象（这里的修改指的是改变引用，而不是改变变量的内容），因为外面的局部变量是不会因为内部的引用改变而改变的，所以强制要求声明为final。但是在Java8中，出现了Effectively final，意思就是，假如这个局部变量我们在使用过程中都不会出现改变引用的情况，那么我们不需要加final，默认是final，如下代码 1234567891011121314151617public class Main &#123; static volatile boolean flag = true; public static void main(String[] args) &#123; Node node = new Node(); new Thread(() -&gt; &#123; node.a = 2; &#125;).start(); &#125; public static class Node &#123; public int a = 1; &#125; &#125; 在Java8编译中编译是不会出错的，然后我们修改一下代码 1234567891011121314151617public class Main &#123; static volatile boolean flag = true; public static void main(String[] args) &#123; Node node = new Node(); new Thread(() -&gt; &#123; node = new Node(); &#125;).start(); &#125; public static class Node &#123; public int a = 1; &#125; &#125; 这时候就会报错，因为我们尝试修改node的值（引用），所以就不是有效final了。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建与遍历]]></title>
    <url>%2F2017%2F02%2F26%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树创建创建根据数组，值为0代表空节点 12345678910private static Node createTree(int[] data, int index) &#123; if (index &gt;= data.length || data[index] == 0) &#123; return null; &#125; Node node = new Node(); node.setValue(data[index]); node.setLeftChild(createTree(data, 2 * index + 1)); node.setRightChild(createTree(data, 2 * index + 2)); return node;&#125; createTree是创建以index索引代表节点为root的树，所以我们首先创建节点赋上对应值，然后设置左右子树，通过递归，最后得到二叉树。 二叉树的深度优先遍历的递归算法深度优先遍历还分为先序、中序、后序。以先序为例，先序就是先访问根节点，再先序遍历左子树，然后先序遍历右子树，很明显可以递归完成。 1234567891011121314151617181920212223242526272829303132333435/** * 先序 * @param root */private static void preOrder(Node root) &#123; if (root != null) &#123; System.out.println(root.getValue() + ""); preOrder(root.getLeftChild()); preOrder(root.getRightChild()); &#125;&#125;/** * 中序 * @param root */private static void inOrder(Node root) &#123; if (root != null) &#123; preOrder(root.getLeftChild()); System.out.println(root.getValue() + ""); preOrder(root.getRightChild()); &#125;&#125;/** * 后序 * @param root */private static void postOrder(Node root) &#123; if (root != null) &#123; preOrder(root.getLeftChild()); preOrder(root.getRightChild()); System.out.println(root.getValue() + ""); &#125;&#125; 二叉树的深度优先遍历的非递归算法先序非递归方法我们使用栈来实现 123456789101112131415161718192021/** * 先序非递归 * @param node */private static void pre(Node node) &#123; if (node == null) &#123; return; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(node); while (!stack.isEmpty()) &#123; Node n = stack.pop(); System.out.println(n.getValue() + ""); if (n.getRightChild() != null) &#123; stack.push(n.getRightChild()); &#125; if (n.getLeftChild() != null) &#123; stack.push(n.getLeftChild()); &#125; &#125;&#125; 首先root入栈，然后循环访问栈顶元素并出栈，接下来将左右子节点入栈，入栈顺序要是先右后左。 后序通过观察可以发现将后序的结果反过来就相当于将二叉树所有左右子树互换后的先序遍历 1234567891011121314151617181920212223/** * 后序非递归 * @param node */private static void after(Node node) &#123; if (node == null) &#123; return; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); List&lt;Node&gt; result = new ArrayList&lt;&gt;(); stack.push(node); while (!stack.isEmpty()) &#123; Node n = stack.pop(); // 加到队列开头 result.add(0, n.getValue()); if (n.getLeftChild() != null) &#123; stack.push(n.getLeftChild()); &#125; if (n.getRightChild() != null) &#123; stack.push(n.getRightChild()); &#125; &#125;&#125; 首先root入栈，然后循环访问栈顶元素并出栈，接下来将左右子节点入栈，入栈顺序要是先右后左。 前/中/后序非递归遍历的通用解法以后序为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main &#123; public static void main(String[] args) &#123; &#125; public List&lt;Integer&gt; traversal(TreeNode root) &#123; // 等待访问的节点 Stack&lt;TreeNode&gt; toVisitStack = new Stack&lt;TreeNode&gt;(); // 访问节点的顺序 List&lt;TreeNode&gt; visitQueue = new ArrayList&lt;TreeNode&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return result; &#125; visitQueue.add(root); toVisitStack.push(root); while (!toVisitStack.isEmpty()) &#123; TreeNode node = toVisitStack.pop(); visitNode(node, visitQueue, toVisitStack); &#125; for (TreeNode treeNode : visitQueue) &#123; result.add(treeNode.val); &#125; return result; &#125; // 后序 private void visitNode(TreeNode node, List&lt;TreeNode&gt; visitQueue, Stack&lt;TreeNode&gt; toVisitStack) &#123; int index = visitQueue.indexOf(node); if (node.left != null) &#123; visitQueue.add(index, node.left); toVisitStack.push(node.left); &#125; index = visitQueue.indexOf(node); if (node.right != null) &#123; visitQueue.add(index, node.right); toVisitStack.push(node.right); &#125; &#125; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;&#125; visitQueue保存的是最后所有节点的访问顺序，从index=0开始，首先我们将root加入visitQueue和toVisitStack，随后从toVisitStack中获取visitNode，将子节点插入visitQueue，这里以后序为例，左右节点均在当前节点之前访问且左节点优先于右节点，所以在visitQueue中的当前节点位置之前插入左右节点，随后将左右节点加入toVisitStack表示后序将对左右节点进行上述操作。 二叉树的广度优先遍历我们可以通过一个队列来保存访问过的节点的左右子节点，然后删除访问过的节点，直到队列为空 1234567891011121314151617private static void layer(Node root) &#123; if (root == null) &#123; return; &#125; List&lt;Node&gt; nodeQueue = new ArrayList&lt;Node&gt;(); nodeQueue.add(root); while (nodeQueue.size() != 0) &#123; Node node = nodeQueue.remove(0); System.out.println(node.getValue() + ""); if (node.getLeftChild() != null) &#123; nodeQueue.add(node.getLeftChild()); &#125; if (node.getRightChild() != null) &#123; nodeQueue.add(node.getRightChild()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用ItemDecoration打造列表顶部悬浮效果]]></title>
    <url>%2F2017%2F01%2F13%2F%E4%BD%BF%E7%94%A8ItemDecoration%E6%89%93%E9%80%A0%E5%88%97%E8%A1%A8%E9%A1%B6%E9%83%A8%E6%82%AC%E6%B5%AE%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[ItemDecoration基本用法ItemDecoration是用来给RecyclerView添加分隔线的，我们可以通过自定义ItemDecoration来实现各种效果，我们先来看一下基本用法。首先我们继承ItemDecoration，要实现三个方法 1234567891011121314@Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125; @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125; getItemOffsets():使用这个方法来给其中一个item（view）添加间隔，用来绘制分割线，比如我们通过parent.getChildAdapterPosition(view)得到这个item的position，然后我们使用outRect.top = 100来使这个item的上面多出100高度的矩形空间用来绘制，对应的left之类的可以类比。 onDraw():用来绘制分割线，一般在这个方法里遍历parent的全部child，然后得到position（注意这里的child只能得到展示在页面的，所以需要额外计算得到真实的position）根据情况看看需不需要绘制分割线。 onDrawOver():和onDraw()很像，区别在于这个绘制的显示在最上方，原因马上说。 在RecyclerView绘制的时候，首先调用onDraw绘制分割线，然后调用自身的onDraw绘制自己（各种item），最后调用onDrawOver绘制，三个绘制用的一个Canvas，所以最后绘制的会覆盖之前的。 代码实战刚看理论肯定云里雾里，这时候就需要敲代码来加深理解和记忆了，我们要完成的效果如下 在RecyclerView中添加数据data1234private String[] data = &#123;"1-你好", "1-你好", "1-你好", "1-你好", "1-你好", "1-你好", "1-你好", "2-OK", "2-OK", "2-OK", "2-OK", "2-OK", "2-OK", "2-OK", "3-你好", "3-你好", "3-你好", "3-你好", "3-你好", "3-你好", "3-你好", "4-OK", "4-OK", "4-OK", "4-OK", "4-OK", "4-OK", "4-OK",&#125;; Adapter12345678910111213141516171819202122232425262728RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; adapter = new RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View v = LayoutInflater.from(MainActivity.this).inflate(R.layout.item_layout, parent, false); return new MyViewHolder(v); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; MyViewHolder viewHolder = (MyViewHolder) holder; viewHolder.textView.setText(data[position]); &#125; @Override public int getItemCount() &#123; return data.length; &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; public TextView textView; public MyViewHolder(View itemView) &#123; super(itemView); textView = (TextView) itemView.findViewById(R.id.text); &#125; &#125;&#125;; item_layout 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="20dp" android:textSize="20sp"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#000"/&gt;&lt;/LinearLayout&gt; 给每一组前面添加组名首先我们需要两个方法分别判断是不是该组第一个item和返回改组的组名 1234567private String getGroupName(int index) &#123; return "第" + (index / 7 + 1) + "组";&#125;private boolean isFirstOfGroup(int index) &#123; return index % 7 == 0;&#125; 然后我们先对每一组第一个item上部添加空间来绘制 12345678@Overridepublic void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int index = parent.getChildAdapterPosition(view); if (isFirstOfGroup(index)) &#123; outRect.top = mTopHeight; &#125;&#125; 这里mTopHeight是组名的高度，然后我们开始绘制 12345678910111213141516171819202122232425262728@Overridepublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); // 得到item真实的left和right（减去parent的padding） int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); for (int i = 0; i != parent.getChildCount(); i++) &#123; // 直接获得的child只有当前显示的，所以就算i是0的index也只是当前第一个，而不是所有第一个 View child = parent.getChildAt(i); int index = parent.getChildAdapterPosition(child); if (isFirstOfGroup(index)) &#123; // 每组第一个item都留有空间来绘制 int top = child.getTop() - mTopHeight; int bottom = child.getTop(); // 绘制背景色 Paint paint = new Paint(); paint.setColor(Color.YELLOW); c.drawRect(left, top, right, bottom, paint); // 绘制组名 paint.setColor(Color.BLACK); paint.setTextSize(60); paint.setTextAlign(Paint.Align.LEFT); paint.setAntiAlias(true); c.drawText(getGroupName(index), left, bottom, paint); &#125; &#125;&#125; 效果如下 添加顶部悬浮我们先来分析一下，平常情况就是顶部绘制一个组名，我们可以通过onDrawOver来覆盖后面的内容达到悬浮的效果。当我们目前页面第二个item是下一组的第一个item的时候情况就不一样了（也就是下一个组马上就要到达顶部的时候），我们的顶部组就会向上发生偏移（像被顶上去的样子），这时候我们只需要计算绘制的bottom是多少就好了（top就是0）。我们可以这样来做 12345678int bottom = 0;if (isFirstOfGroup(index + 1)) &#123; // 下一个组马上到达顶部 bottom = Math.min(child.getBottom(), mTopHeight);&#125; else &#123; // 普通情况 bottom = mTopHeight;&#125; 当下一个组马上到达顶部的时候，我们选择mTopHeight和child.getBottom()中比较小的来作为bottom，这样就可以保证，当悬浮组名bottom超过该组最后一个item的bottom的时候改为最后一个item的bottom，最后消失。最后看一下效果]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Handler详解--实战篇]]></title>
    <url>%2F2016%2F11%2F15%2FHandler%E8%AF%A6%E8%A7%A3-%E5%AE%9E%E6%88%98%E7%AF%87%2F</url>
    <content type="text"><![CDATA[概述之前写了一篇文章讲解Handler机制，但是我觉得理论总是不比实践来的深刻，所以今天我们来自己实现一个Handler。如果没看过之前的文章，建议先看一下Android Handler详解—理论篇。 MyMessageQueue首先实现MyMessageQueue，当然在这之前我们要实现MyMeessage类 1234public class MyMessage &#123; public MyHandler target;&#125; 为了方便，我只写了一个Handler成员变量接下来就是MyMessageQueue的实现 123456789101112131415161718192021222324252627282930public class MyMessageQueue &#123; private volatile List&lt;MyMessage&gt; queue; public MyMessageQueue() &#123; queue = new ArrayList&lt;&gt;(); &#125; public void add(MyMessage message) &#123; queue.add(message); &#125; /** * 取出队头的消息并出队,队列位空的时候阻塞 * @return */ public MyMessage next() &#123; while (true) &#123; if (!queue.isEmpty()) &#123; break; &#125; &#125; MyMessage message = null; synchronized (MyMessageQueue.this) &#123; message = queue.get(0); queue.remove(0); &#125; return message; &#125;&#125; 代码很简单，有两个方法，入队和出队，对列为空的时候出队方法next()会被阻塞直到有新的消息进来。 MyLooperMyLooper的实现依赖ThreadLocal，我们提供prepare()、getLooper()、loop()三个静态方法，在内部维护一个静态的ThreadLocal&lt; MyLooper &gt;变量，通过这个变量设置或获取当前线程的Looper实例。代码如下 1234567891011121314151617181920212223242526272829303132public class MyLooper &#123; private static ThreadLocal&lt;MyLooper&gt; sLooper = new ThreadLocal&lt;&gt;(); public MyMessageQueue queue; public MyLooper() &#123; queue = new MyMessageQueue(); &#125; public static void prepare() &#123; if (sLooper.get() == null) &#123; sLooper.set(new MyLooper()); &#125; &#125; public static MyLooper getLooper() &#123; return sLooper.get(); &#125; public static void loop() &#123; if (sLooper.get() == null) &#123; throw new RuntimeException("no looper exist"); &#125; while (true) &#123; MyMessage myMessage = sLooper.get().queue.next(); //Log.d("Debug", myMessage.toString()); myMessage.target.handleMessage(myMessage); break; &#125; &#125;&#125; 在Looper内部维护一个MessageQueue变量，在loop()方法中无限循环查询queue，有消息就调用Message.target.handleMessage()。但是我们这里在取出一条消息处理之后就跳出循环了，这是为什么呢？不要着急，下面会详细解释，虽然只取一条，但是也足够展示在子线程更新UI的效果了。 MyHandlerMyHandler持有当前线程的Looper，在创建的时候根据当前线程获得，如果当前线程没有Looper则报错。在sendMessage方法中将Message的target赋值，然后入队。 123456789101112131415161718192021public abstract class MyHandler &#123; private MyLooper looper; private MyMessageQueue queue; public MyHandler() &#123; looper = MyLooper.getLooper(); if (looper == null) &#123; throw new RuntimeException("current thread does not have looper"); &#125; queue = looper.queue; &#125; public void sendMessage(MyMessage message) &#123; message.target = MyHandler.this; queue.add(message); &#125; public abstract void handleMessage(MyMessage message);&#125; 效果展示好了，现在我们在布局文件中放一个TextView显示Hello,World 12345678910111213&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:layout_centerInParent="true"/&gt;&lt;/RelativeLayout&gt; MainActivity代码如下 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.text); MyLooper.prepare(); final MyHandler myHandler = new MyHandler() &#123; @Override public void handleMessage(MyMessage message) &#123; textView.setText("change"); &#125; &#125;; new Thread(new Runnable() &#123; @Override public void run() &#123; myHandler.sendMessage(new MyMessage()); &#125; &#125;).start(); MyLooper.loop(); &#125;&#125; 效果图如下 疑点解惑虽然我们完成了子线程更新UI，但是还是有一些问题的，假设我们将Looper的loop方法设为无限循环，而不是取到一条消息就退出循环，那会怎么样？其实都不用试，想一下就知道那主线程就被阻塞了，无法响应用户操作，然后报ANR错误。这样另一个问题就出来了，那为什么主线程原本的Looper不会阻塞呢？他的源码里也是无限循环啊？接下来根据源码来说明一下这个问题。大家都知道java程序有一个入口点public static void main(String[] args)，那既然Android是用java写的，大家一直就不疑惑入口点在哪吗？其实android程序的入口点在ActivityThread这个类当中，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 我们可以看到在代码的最后开启了loop，这里就无限循环了，假设一下，如果没有无限循环，那么main方法就结束了，那程序不就结束了么。。。。Android是基于事件驱动的，也就是说我们的整个应用就是运行在这个最大的Looper循环中的，比如现在系统有一个Activity，在某一情况下需要调用他的onPause方法，怎么办？系统会通过本身的Handler发送一个消息，然后这个Looper获取然后处理（也就是调用Activity的onPause回调方法）。再比如现在啥都不干，那系统就阻塞着，也不会ANR，直到我们有什么动作（比如有触摸事件产生），那么Looper就继续处理。那ANR在什么情况下会发生？ANR只会在handler处理一条消息超过一定时间才会发生，而不是阻塞就会发生（系统基于事件驱动，说明有事件才会动，没事件就阻塞）。]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Handler详解--理论篇]]></title>
    <url>%2F2016%2F11%2F15%2FHandler%E8%AF%A6%E8%A7%A3-%E7%90%86%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[概述在平时的开发中，我们一般会在子线程请求数据，因为Android的UI操作不是线程安全的，所以我们会有切换到UI线程(主线程)更新UI的需求。有以下两种方法： 使用Activity的runOnUiThread方法。 使用Handler。 其实查看源码就能发现runOnUIThread方法还是基于Handler的，接下来就详细解析Handler机制。 相关类Handler机制其实是Handler、MessageQueue、Looper三个类共同作用的结果，只是我们经常和Handler打交道所以对Handler比较熟悉。 MessageQueue这个类相对简单，维护一系列的Message，有两个主要方法 boolean enqueueMessage(Message msg, long when) Message next() enqueueMessage将一条消息入队，next方法返回队头的一条消息，并将该条消息出队，需要注意的是如果消息队列为空，那么这个方法就会阻塞直到有消息入队。 Looper每个线程都有自己的Looper实例，通过Looper.myLooper()获得当前线程的Looper实例，这是通过ThreadLocal实现的，如果不知道ThreadLocal的点这。Looper的作用就是无限循环从MessageQueue中拿消息，拿到消息之后调用方法（后面会讲到）。 先看看Looper类的变量 123456// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue; 除了主线程默认有Looper外，其余的线程若想使用必须调用Looper.prepare()初始化当前线程Looper 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 接下来看看Looper的构造方法 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 可以看出一个Looper持有一个自己的MessageQueue，而且一个线程只会有一个Looper，也就是一个线程一个MessageQueue。 接下来就是最重要的方法了—Loop.loop()，先看看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void loop() &#123; ...... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 可以看出是在一个死循环中从队列取出消息，然后调用msg.target.dispatchMessage(msg)处理消息。其实仔细看会发现如果返回null，那么就会跳出死循环，那么什么时候queue.next()会返回null呢？当Looper的quit被调用的时候，他就会调用queue的quit，这样queue就会返回null，从而达到退出loop的目的。 HandlerHandler作用就是发送消息和处理消息，当一个Handler创建的时候，他就会和当前线程的Looper关联起来 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在构造方法中得到当前线程的Looper和MessageQueue，并保存起来。重头戏在sendMessageAtTime方法，其他方法发送信息最后都是使用这个方法 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 可以看出这里就将消息放入队列了，然后Looper一直在循环消息队列，这个时候他就拿到一条消息，然后调用msg.target.dispatchMessage(msg)处理消息，我们看一下Message的结构 1234567891011121314151617181920212223/** * User-defined message code so that the recipient can identify * what this message is about. Each &#123;@link Handler&#125; has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; /** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg1; /** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg2; /*package*/ Handler target; 可以看出每一条消息都有一个target变量，代表发送他的Handler，而且以后处理消息也是这个Handler，那这个target是在哪里赋值的呢？其实是在sendMessageAtTime中的enqueueMessage()方法 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 梳理流程每个类的原理都讲明白了，接下来我们整理一下他们的关系。一个线程只有一个Looper，一个Looper内部维护着一个MessageQueue，创建Handler的时候，该Handler自动和当前线程的Looper关联起来。当使用该Handler发送消息的时候，使用Handler关联Looper的MessageQueue将消息入队，然后Looper无限循环查询消息队列，一有消息就处理，处理方式是通过调用该Message的target的handleMeessage方法。 线程切换大概流程就是这样，但是可能有人还是很迷糊，那到底是怎么样实现线程的切换的？我们一步一步来看，如果我们的Handler在主线程创建，那么关联的就是主线程的Looper，到最后调用的handleMessage的就是这个Looper，那么该方法就肯定在主线程运行了。而在子线程中，我们做的只不过是发送消息，也就是改变主线程的消息队列，然后主线程的Looper拿到消息处理，这样就实现了线程转换。 下一篇我们会自己实现一个Handler加深对Handler机制对理解，而且还涉及到Android程序启动的流程，有兴趣的朋友可以看一眼。Handler详解--实战篇]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回文字符串问题]]></title>
    <url>%2F2016%2F11%2F09%2F%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述给定一个字符串，问是否能通过添加一个字母将其变为回文串。 思路有两个思路。 如果加一个可以形成回文，那么减去一个也必定可以。可以通过遍历字符串减去一个字符判断是否回文，如果有存在那就输出YES，反之输出NO。 如果字符串首位不一样，那么加上的字符要么是在末尾加上第一个字符，要么是在头部加上末位的字符，判断两种情况是否存在回文串就可以；如果首尾一样，那么就可以略去首尾，继续用这种方法判断。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例]]></title>
    <url>%2F2016%2F11%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[简介当希望一个类在程序中只会有一个实例存在的时候，单例模式便会派上用场。为了限制该类对象被随意的创建，我们将构造方法声明为private，但是这样就无法创建对象了，我们该怎么办呢？接下来就从最简单的单例模式讲起。 最简单的单例1234567891011public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; //初始化操作 &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 我们在类内部创建一个静态的Singleton变量，通过静态方法返回，这样的代码是线程安全的，因为虚拟机加载这个类的时候会保证static的变量只由一个线程执行一次，在使用该变量之前保证创建完成。 性能更进一步第一种方法由于在加载类的时候就会创建static变量，占用内存，这不是我们希望看到的，理想情况是当我们需要用到的时候再创建实例，也就是要延迟实例化，我们修改代码如下 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton() &#123; //初始化操作 &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是这样的话又会造成线程不安全的情况，当两个线程都执行if(instance == null)后，假设线程1先进入下一步，得到一个实例，之后线程2就会进入下一步，同样获得一个新的实例，这就会造成存在多个实例，继续修改代码如下 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton() &#123; //初始化操作 &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 加锁后就可以实现多线程安全访问，但是又出现一个问题，就是在多线程的情况下对整个方法加锁就会造成性能不够好，我们可以缩小同步的范围来加强性能 123456789101112131415161718public class Singleton &#123; private volatile static Singleton instance; private Singleton() &#123; //初始化操作 &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; instance要用volatile修饰，这样就对synchronized有可见性。 静态内部类我们需要的是线程安全且延迟实例化的单例，可以根据第一种代码修改，可以声明一个内部类，内部类里面持有一个Singleton实例，在getInstance方法里获得该内部类的实例，也只会在这个时候jvm去加载这个内部类，创建实例。 12345678910111213public class Singleton &#123; private Singleton() &#123; //初始化操作 &#125; private static class SingleHolder &#123; private static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingleHolder.instance; &#125;&#125; 枚举单例其实以上的方法有一个共同的缺陷，那就是如果将单例序列化存储到本地在读取回来，那么获得另一个一摸一样的instance，这样也就不是所谓的单例了，而单元素的枚举类型是实现Singleton的最佳方法。 枚举的使用最基本的使用如下 12345enum Type &#123; A, B, C;&#125; 编译器将它变成这样 123456class Type extends Enum&#123; public static final Type A; public static final Type B; public static final Type C; ...&#125; 也就是三个静态的Type对象A、B、C。我们可以把Type看成一个类，它也有构造方法和方法 1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args) &#123; Type.staticPrint(); Type.A.print(); Type.B.print(); &#125; enum Type &#123; A, B &#123; @Override public void print() &#123; System.out.println("B print()"); &#125; &#125;, C; Type() &#123; System.out.println("init"); &#125; public static void staticPrint() &#123; System.out.println("static print()"); &#125; public void print() &#123; System.out.println("print()"); &#125; &#125;&#125; 输出： init init init static print() print() B print()可以知道，首先enum会实例化三个静态的Type对象，调用构造方法，构造方法是私有的。我们可以通过Type访问静态的类方法，通过ABC访问实例方法，当然具体的对象如B可以重写父类的实例方法，此外，我们也可以定义抽象方法，这样每个实例ABC都需要实现该方法。 单例的实现1234567891011enum Type &#123; INSTANCE; private Singleton mInstance; private Type() &#123; mInstance = new Singleton(); &#125; public Singleton getInstance() &#123; return mInstance; &#125;&#125; 我们确定了构造方法是私有的，然后我们访问枚举实例的时候会执行构造方法，同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。 也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[变态跳台阶]]></title>
    <url>%2F2016%2F09%2F21%2F%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析令dp[i]表示跳i级台阶不同跳法的数量，假设最后一跳是k阶，那么就有dp[i -k]种跳法，和跳i－k是一样的跳法，k可以取1-i，所以所有方法就是dp[i] = dp[1] + dp[2]+…+dp[i-1] + 1最后的1就是直接跳到i的情况 代码1234567891011121314public int JumpFloorII(int target) &#123; int[] dp = new int[target]; for (int i = 0; i != target; i++) &#123; if (i == 0) &#123; dp[i] = 1; &#125; else &#123; for (int j = 0; j != i; j++) &#123; dp[i] += dp[j]; &#125; dp[i]++; &#125; &#125; return dp[target - 1];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[年终奖问题]]></title>
    <url>%2F2016%2F09%2F20%2F%E5%B9%B4%E7%BB%88%E5%A5%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个66的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。给定一个66的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。 分析可以确定是动态规划，假设dp[i][j]表示从[0,0]到[i,j]的最大值，有以下四种情况 i == 0 &amp;&amp; j == 0的时候，dp[i][j] = board[0][0] i == 0 &amp;&amp; j != 0的时候，路径肯定是[i][j-1]到[i,j]的，dp[i][j] = board[i][j] + dp[i][j-1] i != 0 &amp;&amp; j == 0的时候，和第二种情况类似，dp[i][j] = board[i][j] + dp[i-1][j] i != 0 &amp;&amp; j != 0的时候，dp[i][j] = max{dp[i][j-1], dp[i-1][j]} + board[i][j] 最后输出dp[5][5]就可以了 代码1234567891011121314151617public static int getMost(int[][] board) &#123; int max[][] = new int[6][6]; for (int i = 0; i != 6; i++) &#123; for (int j = 0; j != 6; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; max[i][j] = board[i][j]; &#125; else if (i == 0) &#123; max[i][j] = board[i][j] + max[i][j - 1]; &#125; else if (j == 0) &#123; max[i][j] = board[i][j] + max[i - 1][j]; &#125; else &#123; max[i][j] = Math.max(max[i - 1][j], max[i][j - 1]) + board[i][j]; &#125; &#125; &#125; return max[5][5]; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[左右最值最大差]]></title>
    <url>%2F2016%2F09%2F19%2F%E5%B7%A6%E5%8F%B3%E6%9C%80%E5%80%BC%E6%9C%80%E5%A4%A7%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目描述给定一个长度为N(N&gt;1)的整型数组A，可以将A划分成左右两个部分，左部分A[0..K]，右部分A[K+1..N-1]，K可以取值的范围是[0,N-2]。求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？给定整数数组A和数组的大小n，请返回题目所求的答案。 分析首先可以确定的就是两个数中肯定有一个是A中的最大值。假设是A[i]，这时候我们有两种选择：左边和右边。由于使用k划分为左右两块，那么我们就要确定A[i]在左边还是右边。假设在左边，那我们要取的值肯定是右边的，可以确定的是无论k为多少，最右边的也就是A[n - 1]肯定在范围内，这时候我们判断一下，如果取得不是A[n - 1]，是A[i] ( k &lt; i &lt; n - 1)。如果大于A[n - 1]那我们还不如取A[n - 1]都会比这个差值大（只要调整k让i &lt; k就可以），如果A[i] &lt; A[n - 1]，那不用说我们肯定取A[n - 1],所以无论如何都是最右边的值。另一种情况一样，取最左边的值，所以我们取两端比较小的值就可以。 代码12345678public int findMax(int[] A, int n) &#123; int max = 0; for (int i = 0; i != n; i++) &#123; max = Math.max(max, A[i]); &#125; int min = Math.min(A[0], A[n - 1]); return max - min;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速求二进制中1个数]]></title>
    <url>%2F2016%2F09%2F19%2F%E5%BF%AB%E9%80%9F%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[先放代码 12345678public static int countNum(int n) &#123; int count = 0; while (n != 0) &#123; n &amp;= (n - 1); count++; &#125; return count; &#125; n &amp; (n - 1)能够置位最右边的1为0，这样循环计数，一直到为0就可以知道有多少个1了。那为什么n &amp; (n - 1)能够置位最右边的1为0呢？右边的部分情况肯定是这样的：…..1000..0减去一后就是这样…..0111..1左边省略号部分是不会变的，这样进行&amp;运算后这一部分都变成0了…..0000..0这样最右边的1就置位了。这段代码对于负数也可以用，比如输入－1，输出32。因为负数的二进制表现和正数不一样，负数首位肯定是1，以－1为例，int是32位，首先求1的反码1111…1110，加1就是补码1111..1111所以就是32个1。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最大差值问题]]></title>
    <url>%2F2016%2F09%2F19%2F%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述有一个长度为n的数组A，求满足0 &lt;= a &lt;= b &lt; n的A[b]-A[a]的最大值 思路用到动态规划，假设f[i]表示前i个数组的最大值结果。f[i] 和 f[i - 1]比较就是要不要第i个数字。如果要，那么结果就是A[i] - (前i－1个数字中最小的)；如果不要，那就试f[i] - f[i - 1];这样状态方程就出来了。我们从最小情况i＝0出发，向上递增的同时更新前i－1中的最小值。 代码123456789int f[] = new int[n];int min = a[0];if (n &gt; 1) &#123; for (int i = 1; i != n; i++) &#123; min = Math.min(min, a[i]); f[i] = Math.max(f[i -1], a[i] - min); &#125;&#125;return f[n - 1];]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java线程池简析]]></title>
    <url>%2F2016%2F08%2F30%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[线程池简介我们在实现并发功能时会频繁的创建和销毁线程，这样会加大系统的开销，而线程池会缓存一定数量的线程，可以避免这样的情况，并且线程池可以对现场进行简单的管理，简化了并发编程。 ThreadPoolExecutorJava中的线程池定义为Executor接口，实现这个接口的类为ThreadPoolExecutor，是线程池的真正实现。常用的构造方法为 123456public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) corePoolSize：线程池中的核心线程数量，核心线程理论上会一直存活，就算是闲置状态。 maximumPoolSize：允许线程池最大容纳的线程数，一旦满了，后面新到来的任务会被阻塞。 keepAliveTime：线程闲置的超时时长，闲置时间超过就会被销毁，适用于非核心线程。如果ThredPoolExecutor的allowCoreThreadTimeOut设置为true，那么核心线程也会超时销毁。 unit：超时时长的单位，为枚举类型，常用的有毫秒 TimeUnit.MILLISECONDS、秒TimeUnit.SECONDS、分TimeUnit.MINUTES。 workQueue：任务队列。 threadFactory：提供创建线程的功能。 当任务到来的时候，如果核心线程数量没有达到最大核心线程数量，那么就创建核心线程执行任务。如果超过就将任务插入队列等待核心线程空下来。如果队列也满了，那就只有创建非核心线程（或者复用闲置非核心线程）执行任务。如果全部线程数达到最大值，拒绝执行任务。 四种线程池FixedThreadPool构造函数如下 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程和线程数一样说明只有核心线程，那么线程都不会被回收，可以很快的响应任务。 且队列没有没有大小限制，可以看出新到来的任务肯定不会被拒绝，因为队列不会满，所有任务都可以被执行（核心线程满了就等待）。 CachedThreadPool构造函数如下 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 没有核心线程，且线程数是int的最大值，适用于大量的任务。 SynchronousQueue实际上是不能插入的，所以任务到来的时候，首先没有核心线程，那么就会插入队列等待核心线程，但是这个队列不能插入，所以开启非核心线程执行，也就是说任务到来立马执行，适用于大量且耗时少的任务。 ScheduledThreadPool构造函数如下 123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory);&#125; SingleThreadExecutor构造函数如下 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 就一个核心线程，线程只允许一个，等待队列没限制，也就是说任务是串行执行的，不用考虑同步的问题。 执行任务执行Runnable12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; ExecutorService exe = Executors.newCachedThreadPool(); for (int i = 0; i != 5; i++) &#123; exe.execute(new Task()); &#125; exe.shutdown(); &#125;&#125;class Task implements Runnable &#123; @Override public void run() &#123; // do something here &#125;&#125; 通过execute执行任务，shutdown()方法可以防止新任务被提交给这个Executor，执行完之前的所有任务后会尽快退出。 执行CallableRunnable执行任务不返回任何值，想要有返回值的话可以使用Callable 123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; ExecutorService exe = Executors.newCachedThreadPool(); List&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i != 5; i++) &#123; results.add(exe.submit(new Task())); &#125; exe.shutdown(); for (Future&lt;String&gt; fs : results) &#123; try &#123; System.out.println(fs.get()); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ExecutionException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;class Task implements Callable&lt;String&gt; &#123; public static int i = 0; @Override public String call() &#123; return i++ + ""; &#125;&#125; 首先确定返回值的类型，这里是String，执行的方法是call而不是run。使用submit提交任务而不是execute，submit会返回Future的值，然后我们遍历通过get()方法拿到返回值。值得注意的是，当Future未完成的时候，get()方法会阻塞，直到完成拿到返回值，我们可以通过isDone()判断是否完成。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制详解]]></title>
    <url>%2F2016%2F07%2F21%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述之前在学习android事件方法机制的时候，看过不少文章，但是大部分都讲的不是很清楚，我自己理解的也是云里雾里，也尝试过阅读源码，看得我更是不知所措。最近阅读了《Android开发艺术探索》一书中相关的章节，茅塞顿开，写下本文作为阅读笔记，以便以后查阅。 三个重要的方法1public boolean dispatchTouchEvent(MotionEvent ev) 事件传递过来的时候这个方法第一个被调用，返回结果受当前View的ontouchEvent()方法或者下一级View的dispatchTouchEvent()方法返回值影响。 1public boolean onInterceptTouchEvent(MotionEvent ev) 这个方法是在dispatchTouchEvent()方法内部掉用的，返回值用来判断是否拦截当前事件。 1public boolean onTouchEvent(MotionEvent ev) 也是在dispatchTouchEvent()方法中掉用，用来处理某一事件。 事件的传递规则书中用了一段伪代码来表示 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 也就是说当一个事件到来的时候，当前View的dispatchTouchEvent方法会被调用，在内部首先调用onInterceptTouchEvent判断是否拦截，如果拦截，将事件传递给自己的onTouchEvent对事件进行处理。如果不拦截，就将事件传递给子View，调用子View的dispatchTouchEvent方法，一直到事件被消费。 源码分析上面的内容讲的很抽象，不好理解，接下来配合源码来讲解，这样更加的容易深入理解事件分发机制。 判断是否拦截事件到来的时候，View的第一个工作自然是判断是否拦截，下面给出dispatchTouchEvent中拦截的相关代码 12345678910111213141516// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 这里要注意的是，事件分发机制针对的其实可以看作是一系列的事件，也就是一个事件序列，也就是说一个事件序列由一个DOWN开头，中间n个MOVE，然后以UP或者CANCEL结束。 代码中mFirstTouchTarget在子元素成功处理事件的时候会进行赋值，也就是说当事件不是DOWN，而且没有子元素成功处理的时候，直接拦截事件自己处理。这很好理解，如果不是DOWN说明事件序列已经开始传递了，那么如果子元素不处理最开始的DOWN说明它不想要这个序列，那么就自己处理，一直到新的事件序列到来（也就是新的DOWN）。也就是说一旦我们处理一个事件就不会多次调用onInterceptTouchEvent方法。 另一种情况是DOWN到来，也就是新的事件序列开始，或者子View成功处理过这个序列，就会进行判断。判断第一步是判断FLAG_DISALLOW_INTERCEPT标志位，这个标志位是通过requestDisallowInterceptTouchEvent方法设置的，一般是子View调用的，如果不允许拦截，就不拦截。如果允许，那就调用自己的onInterceptTouchEvent方法来判断。 值得注意的是当DOWN事件到来的时候，会重置标志位，且清除mFirstTouchTarget，就是新序列到来的时候一切重置。 12345678// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 不拦截事件如果最后不拦截事件，那么就应该分发下去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; 就是遍历子View，通过是否在播放动画和事件是否落在它的范围内来获得合适的View，如果存在就调用它的dispatchTouchEvent方法。我们需要获得dispatchTouchEvent返回的值来判断子View是否成功消耗了事件，如果返回的是true代表成功消费，那么就会对mFirstTouchTarget进行赋值 123newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true;break; 这个赋值很重要，如果不消耗那么就不会赋值，也就是说mFirstTouchTarget== null，那么接下来的事件（同一序列，也就不会再产生DOWN了）都有本View消耗，不再分发。 当然，如果最后发现没有合适的子View或者子View返回了false，那么都由本View处理，也就是onTouchEvent，这也就是为什么事件到了最底层还没被消耗（返回true）就会重新向上传递到上一层的onTouchEvent处理的原因了。 拦截事件那就开始自己处理事件，接下来的内容就会详细讲解。 View对事件的处理12345678910ListenerInfo li = mListenerInfo;if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true;&#125;if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true;&#125; 这里的View不包含ViewGroup，可以看到当要处理事件的时候首先判断是否设置了OnTouchListener，如果设置了就调用onTouch方法。如果onTouch返回了true，那么就直接返回，不会去调用ontouchEvent。如果返回了false，就回调用ontouchEvent，返回onTouchEvent的返回值。在onTouchEvent内部，如果设置了OnClickListener就会调用onClick方法。总的来说，就是onTouchListener级别高于onTouchEvent，onClickListener最低。 案例解析针对上述的理论分析，我们通过以下的Demo来结合实践加深理解。首先自定义一个MyViewGroup和MyView，代码如下 12345678910public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 123456789101112131415161718192021222324252627public class MyViewGroup extends ViewGroup &#123; private MyView mChildView; public MyViewGroup(Context context) &#123; this(context, null); &#125; public MyViewGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (changed) &#123; mChildView = (MyView) getChildAt(0); mChildView.layout(l, t, l + mChildView.getMeasuredWidth(), t + mChildView.getMeasuredHeight()); &#125; &#125;&#125; 很简单的自定义View和ViewGroup，我们接下来在布局文件中加入就可以了 123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity"&gt; &lt;com.wulingpeng.viewtouchdispatch.MyViewGroup android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.wulingpeng.viewtouchdispatch.MyView android:layout_width="300dp" android:layout_height="300dp" android:background="@android:color/holo_blue_bright"/&gt; &lt;/com.wulingpeng.viewtouchdispatch.MyViewGroup&gt;&lt;/RelativeLayout&gt; 现在我们重写MyViewGroup和View的相关方法并打印结果 MyView.java12345678910111213@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean dispatch = super.dispatchTouchEvent(ev); Log.d("Debug", "MyView:dispatchTouchEvent " + dispatch); return dispatch;&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; boolean onTouchEvent = super.onTouchEvent(event); Log.d("Debug", "MyView:OnTouchEvent " + onTouchEvent); return onTouchEvent;&#125; MyViewGroup.java123456789101112131415161718192021222324@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean dispatch = super.dispatchTouchEvent(ev); Log.d("Debug", "MyViewGroup:dispatchTouchEvent " + dispatch); return dispatch;&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean isIntercept = false; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: isIntercept = true; &#125; Log.d("Debug", "MyViewGroup:onInterceptTouchEvent " + isIntercept); return isIntercept;&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; boolean onTouchEvent = super.onTouchEvent(event); Log.d("Debug", "MyViewGroup:OnTouchEvent " + onTouchEvent); return onTouchEvent;&#125; 这里我们拦截了DOWN事件，接下来点击MyView的区域然后滑动，最后抬起。 打印结果如下 12307-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:onInterceptTouchEvent true07-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:OnTouchEvent false07-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:dispatchTouchEvent false 明明滑动了一段距离，理论上有很多个MOVE事件，为什么只有三个打印呢？其实之前就已经说明了，我们拦截了DOWN事件，那么子元素是收不到DOWN事件的，结果就是该序列接下来的事件都是我们自己消费，且不会再次掉用onInterceptTouchEvent，由自己的onTouchEvent处理。因为我们的onTouchEvent返回了false，直接导致我们的dispatchTouchEvent也返回了false。那么MyViewGroup的上一层就不会把接下来的事件传递给我们了（上一层的mFirstTouchTarget没有赋值），所以接下来的事件都不会到来。 我们再改变一下，让MyViewGroup的onTouchEvent方法返回true，进行相同的操作，打印结果如下 123407-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:onInterceptTouchEvent true07-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:OnTouchEvent true07-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:dispatchTouchEvent true...... 省略的打印信息就是第二条和第三条的多次重复，也就是说在接下来的MOVE到来的时候，由于之前拦截了DOWN，所以事件自己处理，不会再掉用onIntereptTouchEvent。 注意事项 一般在处理滑动冲突的时候重写相关方法，对于DOWN事件是不会拦截的，也就是返回false，在接下来的MOVE序列中判断是否需要拦截。因为如果拦截了DOWN，那么接下来的事件都不会传给子View了，之前已经分析过了。 一般也不会拦截UP事件，因为UP一般为序列的最后一个事件，拦截不拦截对自己没有什么用处，但是子View就可能因为收不到UP而无法触发click事件。]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义动画实现splash页面3d旋转切换主页面]]></title>
    <url>%2F2016%2F07%2F11%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0splash%E9%A1%B5%E9%9D%A23d%E6%97%8B%E8%BD%AC%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[自定义动画在Animation类中重写方法applyTransformation方法，该方法有两个参数 float interpolatedTime：取值范围为0－1，具体我也不清楚，和时间有关的参数，应该是表示时间过去了多久。 Transformation t：从该参数中可以的到Matrix，通过修改这个Matrix配合interpolatedTime实现动画 接下来实现一个以自身中心缩小到0的demo 12345678910111213141516171819202122public class MyAnimation extends Animation &#123; private int mWidthCenter, mHeightCenter; //重写初始化方法，可以得到当前目标的长宽 @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); this.mWidthCenter = width / 2; this.mHeightCenter = height / 2; setFillAfter(true); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; Matrix matrix = t.getMatrix(); //1－interpolatedTime从1到0完成动画 matrix.setScale( 1 - interpolatedTime, 1 - interpolatedTime, mWidthCenter, mHeightCenter); &#125;&#125; 123MyAnimation animation = new MyAnimation();animation.setDuration(3000);icLauncher.startAnimation(animation); 也可以通过Camera的使用达到3D的效果，接下来修改一下上述代码实现一个图片围绕Y轴旋转的效果 12345678910111213141516171819202122232425262728//创建一个Camera Camera camera = new Camera(); @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); this.mWidthCenter = width / 2; this.mHeightCenter = height / 2; setFillAfter(true); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; Matrix matrix = t.getMatrix(); /* matrix.setScale( 1 - interpolatedTime, 1 - interpolatedTime, mWidthCenter, mHeightCenter); */ camera.save(); camera.rotateY(360 * interpolatedTime); camera.getMatrix(matrix); camera.restore(); //matrix.preTranslate(mWidthCenter, mHeightCenter); //matrix.postTranslate(-mWidthCenter, -mHeightCenter); &#125; 代码不复杂，刚开始创建一个Camera，然后在applyTransformation方法中对camera旋转，xy坐标就是普通的xy坐标，向右x正方向，向下y正方向，camera其实可以看作是在z轴上从上向下看的，也就是我们平时的视角，现在让camera绕y旋转，这里需要注意，我们通过360 ＊ interpolatedTime完成0到360度的旋转，但是每次都是从0开始旋转，所以在旋转之前需要save()保存camera最开始的位置（0的地方），完成旋转后将参数通过getMatrix(matrix)传递给matrix，然后restore()复原。 splash切换效果实现这个效果的思路是在一个FrameLayout中包含两个RelativeLayout，一个是splash，一个是主页面，刚开始主页面是invisible的，然后旋转FrameLayout到90度，这是已经看不见了，然后把splash设为gone，主页设为visible，继续从270转到360。思路就是这样，但是我们需要一个3d旋转的类，我们就靠上面学习的自定义Animation，先贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 实现3d旋转的核心类 */public class Rotate3d extends Animation &#123; private Camera mCamera; private float fromDegrees; private float toDegrees; private int centerX; private int centerY; private boolean reverse; public Rotate3d(float fromDegrees, float toDegrees, int centerX, int centerY, boolean reverse) &#123; this.fromDegrees = fromDegrees; this.toDegrees = toDegrees; this.centerX = centerX; this.centerY = centerY; this.reverse = reverse; &#125; @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); mCamera = new Camera(); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; super.applyTransformation(interpolatedTime, t); Matrix matrix = t.getMatrix(); mCamera.save(); if (!reverse) &#123; // 距离越来越远 mCamera.translate(0, 0, 550 * interpolatedTime); &#125; else &#123; // 距离越来越近 mCamera.translate(0, 0, 550 * (1 - interpolatedTime)); &#125; float degrees = fromDegrees + (toDegrees - fromDegrees) * interpolatedTime; mCamera.rotateY(degrees); mCamera.getMatrix(matrix); mCamera.restore(); // 调整matrix作用的中心 matrix.preTranslate(-centerX, -centerY); matrix.postTranslate(centerX, centerY); &#125;&#125; 基本上面讲过，但有一些不同。我们通过设置camera的z轴距离实现远离和靠近的效果，当splash旋转的时候我们渐渐远离，这是reverse为false，主页出现时渐渐靠近，reverse为true。最后的matrix调整translate是调整matrix作用的中心，pre就是最开始调到中心，动画完成了就调回来。]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Service简析]]></title>
    <url>%2F2016%2F07%2F11%2FService%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介Service作为Android的四大组件之一，它的重要性不言而喻，之前虽说看过一些介绍但是一直没有用过，最近需要用到的时候发现无从下手，便阅读了官方的有关Service的Guide，这里总结一下。 Service作用官方介绍如下 A Service is an application component representing either an application’s desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use. Service主要用于在后台执行长期任务或者耗时操作，在需要的时候甚至可以在应用退出的时候保持运行状态。 Service与Thread虽说Service可以在后台执行任务，但是实际上一个Service是运行在主线程的，如果有耗时操作我们必须在Service中自己开启一个Thread避免ANR。那就会有这么一个问题，我们为什么不用Thread呢？主要的原因就是Thread的可控性不好，假设我们在一个Activity中启动了一个Thread，一旦这个Activity结束了，那么其他的Activity就没有办法拿到这个Thread的引用，更别谈控制了。可是Service不一样，一个Service整个程序只会创建一个实例，而且任何Activity都可以控制，那么Service里的Thread就可以由所有Activity控制了。而且Service作为四大组件之一，有较高级别，在后台运行不容易被系统杀掉。 Service分类Service分为两类 Started Service：不和其他组件通信 Bound Service：可以和其他组件通信 无论使用哪一种Service都必须重写onBind()方法，如果使用Started Service返回null就可以了。 使用Started Service一般需要再重写两个方法 onCreate():启动Service的时候并不存在该Service实例，就会调用该方法。 onStartCommand(Intent intent, int flags, int startId):每次通过startService(Intent intent)启动的时候就会掉用该方法，一般在这里开启新线程。 onStartCommand(Intent intent, int flags, int startId)方法返回int类型的值，代表Service被kill后的行为，有以下三种： START_NOT_STICKY：表示不重新创建 START_STICKY：表示重新创建，调用onStartCommand传入null START_REDELIVER_INTENT：表示重建，调用onStartCommand传入上一个Intent 为了节省资源和电量，我们在任务结束后必须关闭Service，想要关闭Service可以通过本身调用stopSelf()或者其他组件调用stopService(),但是如果我们的Service处理多个onStartCommand请求的时候，我们在请求结束后掉用stopSelf()可能会打断已经收到的新的请求，最好的情况就是我们本身就是最后一个请求，stopSelt(int)的一个参数的重载可以解决这个方法，传入的id就是onStartCommand传递进来的id，代表当前任务的id，它会把传入的id和最后一个id比较，如果一样的话就代表本身是最后一个任务，就会stop掉，否则不会执行stop。 使用Bound Service主要和Started Service的区别就是可以和其他组件通信，通过Binder。创建时必须定义接口描述用户如何与Server交流，接口必须继承Binder。使用bindService()创建，必须提供一个ServiceConnection的实现，，bindService()是一个异步方法，立马回返回。当创建完后会调用ServiceConnection的onServiceConnected，并传递binder通信。onBind方法只在第一个用户连接调用，后来都返回同一个binder（因为只会有一个Service），代码如下 1234567891011121314151617181920212223public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125; bind service的代码如下 1234567891011121314private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;; 1bindService(intent, mConnection, 0); 可以看出我们在Service中自定义了binder继承自Binder，并声明了一个方法，然后在onBind()中返回一个实例。我们会在onServiceConnected方法中得到这个binder，然后我们调用里的方法得到Service的实例，这样就可以掉用里面方法了，也就完成了通信。bindServicer第三个参数是刚开始的选择，如果是BIND_AUTO_CREATE表示如果没启动就新建 注意事项onServiceDisconnected方法不是unbind的时候调用的，实在被kill等意外情况调用的]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PagerSlidingTabStrip源码解析]]></title>
    <url>%2F2016%2F07%2F05%2FPagerSlidingTabStrip%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[项目简介项目地址https://github.com/astuetz/PagerSlidingTabStrip该项目是一个配合ViewPager使用的指示器控件，这里的ViewPager的adapter必须是继承FragmentPagerAdapter，且需要重写getPageIconResId(int position)或者getPageTitle(int position)以便指示器显示内容。 使用方法首先在布局文件中包含PagerSlidingTabTrip和ViewPager 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;com.astuetz.PagerSlidingTabStrip android:id="@+id/indicator" android:layout_width="match_parent" android:layout_height="48dp" android:background="#fff5f5f5" android:textSize="16sp" android:textColor="@drawable/selector_indicator_text_color" app:pstsShouldExpand="true" app:pstsIndicatorHeight="4dp" app:pstsIndicatorColor="@color/red" app:pstsUnderlineHeight="0dp" app:pstsDividerColor="#fff5f5f5"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/view_pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt;&lt;/LinearLayout&gt; 然后绑定ViewPager 1234indicator = (PagerSlidingTabStrip) findViewById(R.id.indicator); viewPager = (ViewPager) findViewById(R.id.view_pager); viewPager.setAdapter(new FragmentAdapter(getFragmentManager())); indicator.setViewPager(viewPager); 这里需要注意的是如果要为ViewPager设置OnPageChangeListener应该设置在indicator里，而不是直接为ViewPager设置，至于为什么下面会解释。 源码解析从构造方法开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public PagerSlidingTabStrip(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); setFillViewport(true); setWillNotDraw(false); tabsContainer = new LinearLayout(context); tabsContainer.setOrientation(LinearLayout.HORIZONTAL); tabsContainer.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); addView(tabsContainer); DisplayMetrics dm = getResources().getDisplayMetrics(); scrollOffset = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, scrollOffset, dm); indicatorHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, indicatorHeight, dm); underlineHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, underlineHeight, dm); dividerPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerPadding, dm); tabPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, tabPadding, dm); dividerWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerWidth, dm); tabTextSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, tabTextSize, dm); // get system attrs (android:textSize and android:textColor) TypedArray a = context.obtainStyledAttributes(attrs, ATTRS); tabTextSize = a.getDimensionPixelSize(0, tabTextSize); tabTextColor = a.getColor(1, tabTextColor); a.recycle(); // get custom attrs a = context.obtainStyledAttributes(attrs, R.styleable.PagerSlidingTabStrip); indicatorColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsIndicatorColor, indicatorColor); underlineColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsUnderlineColor, underlineColor); dividerColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsDividerColor, dividerColor); indicatorHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsIndicatorHeight, indicatorHeight); underlineHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsUnderlineHeight, underlineHeight); dividerPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsDividerPadding, dividerPadding); tabPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsTabPaddingLeftRight, tabPadding); tabBackgroundResId = a.getResourceId(R.styleable.PagerSlidingTabStrip_pstsTabBackground, tabBackgroundResId); shouldExpand = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsShouldExpand, shouldExpand); scrollOffset = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsScrollOffset, scrollOffset); textAllCaps = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsTextAllCaps, textAllCaps); a.recycle(); rectPaint = new Paint(); rectPaint.setAntiAlias(true); rectPaint.setStyle(Style.FILL); dividerPaint = new Paint(); dividerPaint.setAntiAlias(true); dividerPaint.setStrokeWidth(dividerWidth); defaultTabLayoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); expandedTabLayoutParams = new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f); if (locale == null) &#123; locale = getResources().getConfiguration().locale; &#125; &#125; 在构造方法中先是new了一个LinearLayout作为tab的容器，然后取得一些属性，完成了一些初始化操作。 接下来看一下setViewPager(ViewPager pager)方法 1234567891011public void setViewPager(ViewPager pager) &#123; this.pager = pager; if (pager.getAdapter() == null) &#123; throw new IllegalStateException("ViewPager does not have adapter instance."); &#125; pager.setOnPageChangeListener(pageListener); notifyDataSetChanged();&#125; 这里将viewpager保存起来，然后设置listener，不过这里的listener是一个内部类，等下再来分析这个类，在该方法的最后调用方法notifyDataSetChanged()，我们来看一下 123456789101112131415161718public void notifyDataSetChanged() &#123; tabsContainer.removeAllViews(); tabCount = pager.getAdapter().getCount(); for (int i = 0; i &lt; tabCount; i++) &#123; if (pager.getAdapter() instanceof IconTabProvider) &#123; addIconTab(i, ((IconTabProvider) pager.getAdapter()).getPageIconResId(i)); &#125; else &#123; addTextTab(i, pager.getAdapter().getPageTitle(i).toString()); &#125; &#125; ......&#125; 这里主要完成tab的初始化，没有什么难度。接下来就是比较重要的PageListener类了 123456789101112131415161718192021222324252627282930313233343536private class PageListener implements OnPageChangeListener &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; currentPosition = position; currentPositionOffset = positionOffset; scrollToChild(position, (int) (positionOffset * tabsContainer.getChildAt(position).getWidth())); invalidate(); if (delegatePageListener != null) &#123; delegatePageListener.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; if (state == ViewPager.SCROLL_STATE_IDLE) &#123; scrollToChild(pager.getCurrentItem(), 0); &#125; if (delegatePageListener != null) &#123; delegatePageListener.onPageScrollStateChanged(state); &#125; &#125; @Override public void onPageSelected(int position) &#123; if (delegatePageListener != null) &#123; delegatePageListener.onPageSelected(position); &#125; &#125;&#125; 该控件提供一个setOnPageChangeListener()方法允许用户设置自己的Listener，然后在PageListener类中每个方法都会在listener非空 的情况下调用相应方法。在ViewPager滑动的时候调用scrollToChild方法滑动自身，然后通过invalidata触发onDraw绘制indicator。绘制的主要代码为 12345678910111213...... if (currentPositionOffset &gt; 0f &amp;&amp; currentPosition &lt; tabCount - 1) &#123; View nextTab = tabsContainer.getChildAt(currentPosition + 1); final float nextTabLeft = nextTab.getLeft(); final float nextTabRight = nextTab.getRight(); lineLeft = (currentPositionOffset * nextTabLeft + (1f - currentPositionOffset) * lineLeft); lineRight = (currentPositionOffset * nextTabRight + (1f - currentPositionOffset) * lineRight); &#125; canvas.drawRect(lineLeft, height - indicatorHeight, lineRight, height, rectPaint);...... 改变一下就可以发现lineLeft = lineLeft + (nextTabLeft - lineLeft) currentPositionOffsetlineRight = lineRight + (nextTabRight - lineRight) currentPositionOffset而且nextTabLeft - lineLeft就是当前tab的width，nextTabRight - lineRight是下一个tab的width所以最后就是lineLeft = lineLeft + currentWidth currentPositionOffsetlineright = lineRight + nextWidth currentPositionOffset这样的写法可以动态改变indicator的width。值得注意的是我们发现在无论是scrollToChild()还是onDraw()中都用的是tab.getLeft()，那么我们一个一个来分析。在scrollToChild()中，是使用scrollTo()滑动scrollview，tab.getLeft()得到的是相对于父控件的距离，也就是相对于LinearLayout的距离，这样无论怎么滚动，任何tab的left都是不会变的，因为是相对于LinearLayout的距离，而LinearLayout是不会变的。然后根据该left加上偏移量去scrollTo()，就会正好向左滑动让tab靠在最左边。onDraw()中主要是为了绘制indicator，canvas的绘制应该是绘制在本身的，也就是绘制在HorizontalScrollView上的，经过试验发现如果我们draw的left为0，那么会显示在LinearLayout的最左边，也就是说left为0的位置并不是在显示的最左端，而是实际上内容的最左端，可以把整个控件想象为完全展开的，left就是最左边，虽然有可能因为滑动而被挡住，没有显示出来。]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0-1背包问题]]></title>
    <url>%2F2016%2F04%2F17%2F0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.问题描述 有n个物品，第i个物品的体积和价值分别为w[i]、vi，现有一个容量为c的背包，将这些物品选择装入该背包，如何选择使得包里的物品价值总和最大。 2.问题分析 定义函数f[i][w]表示从前i件物品中选择放入容量为w的背包能装下的物品最大价值，我们所要求的就是f[n][c]。以n为例，有两种情况: a. 如果w[n]&gt;c，那么n就不能选中，即f[n][c] = f[n-1][c] b. 如果w[n] &lt;= c, 那么n有可能选中也可能没有选中，依据就是判断选中和不选中的结果哪个大酒根据那一个，即比较f[n-1][c-w[n]]+v[n]和f[n-1][c] 3.编写代码 在解决该问题时因为每一个f都依赖上一个结果，所以需要从最小的f开始向上计算，得到结果，易得f[0][i] f[i][0]都是0，我们需要从0开始计算出所有f[][]12345678910//i表示从前i项选择，j表示容量for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (w[i] &gt; j) &#123; f[i][j] = f[i - 1][j]; &#125; else &#123; f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125;&#125; 完整代码如下1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cmath&gt; using namespace std; int knapsack(int n, int c, int v[], int w[]) &#123; int f[1001][1001] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (w[i] &gt; j) &#123; f[i][j] = f[i - 1][j]; &#125; else &#123; f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125; return f[n][c];&#125; int main () &#123; int n, v[1001]; int c, w[1001]; while (cin &gt;&gt; n &gt;&gt; c) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; cout &lt;&lt; knapsack(n, c, v, w) &lt;&lt; endl; &#125; return 0;&#125; 如果想得到选择的具体情况可以通过f[i][c]-f[i-1][c]的值判断,如果f[i][c]&gt;f[i-1][c],那么就是选取了第i个，接下来就要判断f[i - 1][c - w[i]] 和f[i - 2][c - w[i]]，注意i从大到小判断，遇到被选中的，加下来的判断就要减去这个重量1234567int w = totalWeight;for (int i = n; i != 0; i--) &#123; if (f[i][w] &gt; f[i - 1][w]) &#123; cout &lt;&lt; i &lt;&lt; " "; w -= w[i]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[交换排序之快速排序]]></title>
    <url>%2F2016%2F03%2F17%2F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序的基本思路是选取一个基准数，然后将小于基准数的移到基准数左边，反之在右边，称为一趟快速排序。然后以基准数分为左右两组，分别快速排序，如此递归，完成最终排序。 一般基准数选取第一个数据，接下来重点在于一趟排序中如何移动数据。如数据data[] = {4 3 6 2 1}，data[0] = 4为基准，将4搬出，则data[0]一个空位，设置标志位i = 0, j = 4。先递减j，因为右边的是大于4的，所以找到小于4的移到左边的空位，然后递增i找到大于4的移到之前j移动后的空位 如此反复直到i ＝ j结束。此时i ＝ j肯定是一个空位 将4移动到这，第一趟结束，接下来递归就可以了。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std; const int N = 10; void quickSort(int *data, int left, int right) &#123; //排序结束 if (left &gt;= right) &#123; return; &#125; int base = data[left]; int i = left; int j = right; //循环直到i＝j while (i != j) &#123; //先从右边开始，因为基准取的是第一个数据 //当数据大于基准数继续递减 while (i &lt; j &amp;&amp; data[j] &gt;= base) &#123; j--; &#125; //如果i&lt;j 则data[j] &lt; base，移动 if (i &lt; j) &#123; data[i] = data[j]; &#125; //同理 while (i &lt; j &amp;&amp; data[i] &lt;= base) &#123; i++; &#125; if (i &lt; j) &#123; data[j] = data[i]; &#125; &#125; //最后移动基准数 data[i] = base; //递归 quickSort(data, left, i - 1); quickSort(data, i + 1, right); &#125; int main() &#123; int data[N]; for (int i = 0; i != N; i++) &#123; cin &gt;&gt; data[i]; &#125; quickSort(data, 0, N - 1); for (int i = 0; i != N; i++) &#123; cout &lt;&lt; data[i] &lt;&lt; " "; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
